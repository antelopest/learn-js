/*
14.11.2019

Функциональное программирование - это такой стиль разработки программ, в котором шикоро используются некоторые
специфические возможности по работе с функциями. Речь идет, в частности, о передаче функций другим функциям
в качестве аргументов и о возврате функций из других функций.
К функциональному стилю программирования относится и понятие "чистые функции". Выходные данные чистых функций
зависят только от входных, они при выполнении, не влияют на состояние программы.

Принципы функционального программирования поддерживает множество языков.
Среди них можно отметить: JS, Haskell, Clojure, Erlang.

Композиция функции

Повторное использование кода - хорошая затея, но в реальности этого тяжело добиться.
Попробуйте сделать код слишком специализированным и у вас не получится использовать его снова.
Попрубуйте сделаеть код слишком общим и вам будет сложно использовать его даже в вашей первоочередной задаче.
Баланс между двумя положениями, способ создавать элементы поменьше с возможностью многократного использования,
которые мы будем применять как строительные блоки для конструирования более сложного функционала.

В функциональном программировании функции это строительные блоки.
Мы пишем их для определенных задач, а потом складываем вместе, как строительные блоки в Lego.

Результат такого сложения называется композицией функции.

Пример:
*/

const add10 = function (value) {
  return value + 10;
};

const mult5 = function (value) {
  return value * 5;
};

const add10_ = value => value + 10;
const mult5_ = value => value * 5;

const mult5_add10 = value => 5 * (value + 10);
const mult5АfterAdd10 = value => mult5(add10_(value));

/*
* В математике FoG - композиция функций (суперпозиция функции) и читается она как
* применение функции f к результату функции g или более просто выполнение f после g.
* (FoG)(x) - эквивалент вызова функции F после функции G со значением x или еще проще
* F(G(x))
*
* В JS нативно не реализует возможность композиции функций
*
* На языке Elm
* f x =
*   (g << h << s << r << t) x
* В функцию t передается x, чей результат передается в r, далее s, h, g
*
* На языке JS
* g(h(s(r(t(x))))
* */

/*
* Бесточечная нотация - стиль описания функции без предварительного указания входных параметров указания входных параметров.
* По началу такой стиль будет казатья необычным, но по мере продолжения, можно будет оценить лаконичность такого подхода.
* */



/*
Каррирование

Использование механизмов функционального программирования подразумевает знание, кроме прочих, таких концепций,
как чистые функции, каррирование функций, функции высшего порядка.

Что такое каррирование?
Каррирование или карринг (currying) в функциональном программировании - это преобразование функции с множеством аргументов
в набор вложенных функций с одним аргументом. При вызове каррированой функции с передачей ей одного аргумента, она возвращает
новую функцию, которая ожидает поступления следующего аргумента. Новые функии, ожидающие следующего аргумента,
возвращаютя при каждом вызове каррировании функции - до тех пор, пока функция не получит необходимые ей аргументы.
Ранее полученные аргументы, благодаря механизму замыканий, ждут того момента, когда функция получит все, что ей нужно
для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.

Коротко
Каррирование - превращение функции с множеством аргументов в функцию с меньшей арностью.

Арность - это количество аргументов функции.

Например:
*/

function fn(a, b) {
  // ..
}
function _fn(a, b, c) {
  // ..
}

/*
Функция fn принимает два аргумента (это бинарная или 2-арная функция)
Функция _fn принимает три аргумента (тернарная, 3-арная функция)


Пример:
 */

function multiply (a, b, c) {
  return a * b * c;
}

multiply(1, 2, 3);
/*
 Функция multiply принимает три аргумента и возвращает их произведение

 Процесс каррирования для функции multiply будет выглядеть следующим образом:
*/

function _multiply(a) {
  return (b) => {
    return (c) => {
      return a * b * c;
    }
  }
}

console.log(_multiply(1)(2)(3));

// or

const mul_1 = _multiply(1);
const mul_2 = mul_1(2);
const mul_3 = mul_2(3);

// В каждой последующей функции имеется ссылка на функцию, принимающая следующий аргумент
// Функция mul_3 имеет самый большой уровень вложенности, имеет доступ к областям видимости, к замыканиям, формируемым
// функциями mul_1 и mul_2


// Еще один пример. Вычисления объема прямоугольного параллелепиреда.
function volume(l,w,h) {
  return l * w * h;
}
const vol = volume(100,20,90) // 180000

function _volume(l) {
  return (w) => {
    return (h) => {
      return l * w * h
    }
  }
}
const _vol = _volume(100)(20)(90) // 180000

/*
* Каррирование и частичное применение функций
* Количество аргументов = количеству вложенных функций, если речь идет о каррировании то это так.
*
* При частичном применении функцию преобразуют в другую функцию, обладающую меньшим числом аргументов (меньшей арностью)
* Некоторые функции такой функции оказываются фиксированнми (для них задаются значения по умолчанию)
*
* Пример
 */

function acidityRadio(x, y, z) {
  // return repformOP(x, y, z);
}

// Можно преобразовать в такую
function acidityRatio(x) {
  return (y, z) => {
    // return repformOp(x, y, z);
  }
}

/*
* Функцию, которую можно получить, вызвав новую функцию acidityRatio() с аргументом,
* значение которого нужно зафиксировать, представляет собой исходную функцию,
* один из аргументов которой зафиксирован, а сама эта функция принимает на один аргумент меньше, чем исходная.
*
* Каррированный вариант функции будет выглядеть так:
* */

function acidityRatio(x) {
  return (y) => {
    return (z) => {
      // return performOp(x,y,z)
    }
  }
}

/*
Итоги

В этом материале мы поговорили о каррировании и частичном применении функций.
Эти методы преобразования функций реализуются в JavaScript благодаря замыканиям и благодаря тому,
что функции в JS являются объектами первого класса (их можно передавать в качестве аргументов другим функциям,
возвращать из них, присваивать переменным).
 */
