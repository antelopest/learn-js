# 13 August 2025

## 1. Развернуть строку без использования встроенного метода reverse()

```js
// Пример:
// input: "JavaScript"
// output: "tpircSavaJ"

function reverseString(str) {
}
```

### Решение

```js
function reverseString(str) {
    let array = [];

    for (let i = str.length - 1; i >= 0; i--) {
        array.push(str[i]);
    }

    return array.join('');
}
```

### Улучшения

```js
function reverseString(str) {
    let reversed = '';

    for (let i = str.length - 1; i >= 0; i--) {
        reversed += str[i];
    }

    return reversed;
}
```

Без дополнительного массива, сокращается использование памяти.

### Прочие решения

```js
function reverseString(str) {
    return str.split('').reduce((acc, cur) => cur + acc, '');
}
```

## 2. Уникальные значения в массиве

Напиши функцию, которая возвращает новый массив только с уникальными значениями.

```js
// Пример:
// input: [1, 2, 2, 3, 4, 4, 5]
// output: [1, 2, 3, 4, 5]

function uniqueArray(arr) {
}
```

### Решение

#### Решение с помощью структуры данных Set

```js
function uniqueArray(arr) {
    return [...new Set(arr)];
}
```

#### Решение с помощью Array методов filter, indexOf

```js
function uniqueArray(arr) {
    return arr.filter((item, index) => arr.indexOf(item) === index);
}
```

#### Решение через Object

```js
function uniqueArray2(arr) {
    const obj = {};
    const uniques = [];

    for (const item of arr) {
        if (!obj[item]) {
            uniques.push(item);
            obj[item] = true;
        }
    }

    return uniques;
}
```

## 3. Асинхронный запрос с обработкой ошибок

Симулируй запрос на сервер с помощью fetch или setTimeout, обрабатывай успешный результат и ошибки.

```js
// Условие:
// - Если промис resolve, вывести "Data: ..."
// - Если reject, вывести "Error: ..."

async function getData() {
    // твой код
}
```

### Решение

```js
async function getData() {
    function fakeFetch() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (Math.random() > 0.3) {
                    resolve('Data');
                } else {
                    reject('Error fetching data');
                }
            }, 1000);
        });
    }

    try {
        const data = await fakeFetch();
        console.log(`Data: ${data}`)
    } catch (error) {
        console.log(`Error: ${error}`)
    }
}
```

## 4. Реализовать функцию debounce

Функция должна откладывать выполнение переданной функции, пока не пройдет заданное время после последнего вызова.

```js
function debounce(fn, delay) {
}

const log = debounce(() => console.log('Hello'), 1000);
log();
log(); // Выполнится только один раз через 1 секунду после последнего вызова
```

### Решение

#### Классическое решение

```js
function debounce(fn, delay) {

    let timeoutId;

    return function (...args) {
        clearTimeout(timeoutId);

        timeoutId = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    }
}
```

#### debounce с отменой

```js
function debounce1(fn, delay) {
    let timeoutId;

    function debounced(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    }

    debounced.cancel = () => {
        clearTimeout(timeoutId);
    }

    return debounced;
}
```

## 5. Имитация работы Array.prototype.map

Напиши свою реализацию метода `map`, который повторяет поведение встроенного.

```js
function myMap(arr, callback) {
    // твой код
}

// Пример:
const result = myMap([1, 2, 3], num => num * 2);
console.log(result); // [2, 4, 6]
```

### Решение

```js
function myMap(arr, callback, thisArg) {
    const result = new Array(arr.length);

    for (let i = 0; i < arr.length; i++) {
        if (i in arr) { // пропуск пустых слотов
            result[i] = callback.call(thisArg, arr[i], i, arr);
        }

    }

    return result;
}
```