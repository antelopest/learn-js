# 24 July 2025

Практическое собеседование

## Задача 1. Типы и преобразования

Что выведет код? Объясните почему.

```js
console.log([] + 1);
console.log({} + []);
console.log(null == undefined);
console.log(null === undefined);
```

**Цель:** Проверить понимание типов и различий между == и ===.

### Ответ

## Задача 2. Замыкание

Напиши функцию, которая возвращает массив функций. Каждая функция при вызове должна возвращать свое число:

```js
const createFunctions = () => {
    // твой код
}

const funcs = createFunctions();

console.log(funcs[0]()); // 0
console.log(funcs[1]()); // 1
console.log(funcs[2]()); // 2
```

**Цель:** Проверка понимания замыканий и области видимости переменных в цикле.

### Ответ

## Задача 3. Работа с массивами

Напиши функцию, которая принимает массив числе и возвращает новый массив без повторений:

```js
const removeDublicates = (arr) => {
    // твой код
}

console.log(removeDublicates([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```

**Цель:** Проверить знания по работе с массивами, множествами (Set), методами filter, includes, reduce и тд.

### Ответ

## Задача 4. Плоский массив

Напиши функцию, которая преобразует вложенный массив в "плоский" (одномерный):

```js
const flatten = (arr) => {
    // твой код
}

console.log(flatten([1, [2, [3, 4], 5], 6])); // [1, 2, 3, 4, 5, 6]
```

**Цель:** Проверка знания рекурсии, циклов, методов массивов (flat, reduce и тд)

### Ответ

### Задача 5. Асинхронность

Что выведется в консоль и почему?

```js
console.log('start');

setTimeout(() => {
    console.log('timeout');
}, 0);

Promise.resolve().then(() => {
    console.log('promise');
});

console.log('end');
```

Ожидаемый вывод:

```
start
end
promise
timeout
```

**Цель:** Проверка понимания Event Loop, микротасков и макротасков.

### Ответ

Event Loop - это механизм управления выполнения синхронного и асинхронного кода в однопоточной среде, на JavaScript в
среде выполнения Node.js и
в браузере. JavaScript выполняется в одном потоке, но благодаря Event Loop он может обрабатывать асинхронные операции,
такие как таймеры, события DOM, промисы и сетевые запросы, без блокирования основного потока.

Event Loop состоит из:

* Call Stack (Стек вызовов) - стек в котором, хранятся функции, которые выполняются в данный момент. Работает по
  принципу, последний пришел, первым ушел.
* Task queue (Очереди задачи) - очереди макрозадачи (setTimeout, EventListener (событие DOM), setInterval, fetch).
* Microtask queue (Очереди микрозадач) - очереди микрозадач (promise.then, queueMicrotask, MutationObserver).
* Render queue (Очереди на рендер UI) - очередь задач на рендинг UI (перерисовка страницы).
* WebAPIs в браузере (например setTimeout, fetch, DOM-события) обрабатываются вне основного потока, после выполнения,
  возвращает результат в очереди Microtask queue или Macrotask queue.

Как работает Event Loop:

1. JavaScript выполняет весь синхронный код в Call Stack
2. Когда встречается асинхронная операция (setTimeout, fetch, setInterval) она передается в Web APIs на выполнение.
3. После завершения асинхронных операций Web APIs передает результаты в соответствующие Task queue или Microtask queue.
4. Event Loop проверяет:
    * Если Call Stack пуст, сначала выполняются все микротаски из Microtask Queue.
    * Затем, если нужно, выполняется рендеринг (Render Queue)
    * После этого выполняет ода макротаска из Task Queue.

Этот процесс повторяется, пока очереди не опустеют.

Рассмотрим наш пример:

```js
console.log('start'); // Синхронный код выполняется сразу в Call Stack

setTimeout(() => {
    console.log('timeout');
}, 0); // Macrotask - передается на выполнение в Web APIs, после завершения результат будет отдан в очередь макрозадач.

Promise.resolve().then(() => {
    console.log('promise');
}); // Microtask - передается на выполнение в Web APIs, после завершения результат будет возвращет в очередь микрозадач.

console.log('end'); // Синхронный код выполняется сразу в Call Stack
```

Результат:

```
start
end 
promise
timeout
```

```
Call Stack:
- console.log('start')   -> выполнен
- setTimeout(...)        -> передан в Web API (macrotask)
- Promise.then(...)      -> в Microtask Queue
- console.log('end')     -> выполнен

Затем:
Microtask Queue:
console.log('promise')

Потом:
Macrotask Queue:
console.log('timeout')
```