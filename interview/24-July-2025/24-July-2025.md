# 24 July 2025

Практическое собеседование

## Задача 1. Типы и преобразования

Что выведет код? Объясните почему.

```js
console.log([] + 1);
console.log({} + []);
console.log(null == undefined);
console.log(null === undefined);
```

**Цель:** Проверить понимание типов и различий между == и ===.

## Ответ

Разница между операторами `==` и `===`

* `==` - оператор нестрого сравнения (с приведением типов)
* `===` - оператор строгого сравнения (без приведения типов)

### Пример

```js
console.log("5" === 5); // false
```

### Почему?

При сравнении значений использовался оператор строгого сравнения без приведения типов.

Результатом сравнения будет false.

### Оператор `+`

Выполняет операцию сложения.
Если одно значение из операндов является строкой, тогда второй операнд будет тоже преобразован в строку.

### Пример

```js
console.log("5" + 5 == 55); // true
```

### Почему?

Первое значение:`"5" + 5 => "55"`
Так как сложение происходит между строкой и числом, число будет приведено в строку.
Результатом сложения будет строка "55".

Нестрогое сравнение преобразует строку "55" в число 55.

Второе значение: 55

Результат сравнения true

### Рассмотрим наши примеры

```js
console.log([] + 1); // "1"
console.log({} + []); // 0 или [object Object]
console.log(null == undefined); // true
console.log(null === undefined); // false
```

1. `console.log([] + 1); // 1`

    * `[]` - пустой массив, при приведении к примитиву `[].toString() -> ""` (пустая строка)
    * `"".concat(1)`
    * Результат: "1"

2. `console.log({} + []); // 0`

    * {} - блок кода
    * +[] - унарный плюс, примененный к массиву, равен 0
    * Результат: 0

3. `console.log(null == undefined); // true`

    * По спецификации, null и undefined равны между собой
    * Они не равны не числу, ни строке, ни объекту
    * Результат: true

4. `console.log(null === undefined); // false`
   * null и undefined - это разные типы данных
   * typeof null === 'object'
   * typeof undefined === 'undefined'
   * Результатом будет false

## Задача 2. Замыкание

Напиши функцию, которая возвращает массив функций. Каждая функция при вызове должна возвращать свое число:

```js
const createFunctions = () => {
    // твой код
}

const funcs = createFunctions();

console.log(funcs[0]()); // 0
console.log(funcs[1]()); // 1
console.log(funcs[2]()); // 2
```

**Цель:** Проверка понимания замыканий и области видимости переменных в цикле.

## Ответ

Разные решение:

### С использованием Array, fill, map

```js
const createFunctions = (n = 3) => {
    return new Array(n).fill(0).map((e, i) => {

        return () => {
            return i;
        }
    });
}
```

### С использованием var и немедленно вызываемой функцией (IIFE) (замыкание до появления ES6)

```js
const createFunctions = (n = 3) => {
    const result = [];

    for (var i = 0; i < n; i++) {
        (function (j) {
            result.push(() => j);
        })(i);
    }

    return result;
}
```

### С использованием for и let

```js
const createFunctions = (n = 3) => {
    const result = [];

    for (let i = 0; i < n; i++) {
        result.push(() => i);
    }

    return result;
}
```

## Задача 3. Работа с массивами

Напиши функцию, которая принимает массив чисел и возвращает новый массив без повторений:

```js
const removeDublicates = (arr) => {
    // твой код
}

console.log(removeDublicates([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```

**Цель:** Проверить знания по работе с массивами, множествами (Set), методами filter, includes, reduce и тд.

## Ответ

Несколько решений:

### С использованием уникального множества Set

```js
const removeDuplicates = arr => Array.from(new Set(arr));
```

### С использованием императивного стиля

```js
const removeDuplicates = arr => {
    const result = [];

    for (let i = 0; i < arr.length; i++) {
        let element = arr[i];

        if (result.includes(element)) continue;

        result.push(element);
    }

    return result;
}
```

### С использованием reduce

```js
const removeDuplicates = arr => arr.reduce((result, element) => {
    if (result.includes(element)) return result;

    result.push(element);

    return result;
}, []);
```

### С использованием filter

```js
const removeDuplicates = arr => arr.filter((element, index) => arr.indexOf(element) === index);
```

## Задача 4. Плоский массив

Напиши функцию, которая преобразует вложенный массив в "плоский" (одномерный):

```js
const flatten = (arr) => {
    // твой код
}

console.log(flatten([1, [2, [3, 4], 5], 6])); // [1, 2, 3, 4, 5, 6]
```

**Цель:** Проверка знания рекурсии, циклов, методов массивов (flat, reduce и тд)

## Ответ

У меня есть несколько реализаций:

### Использование flat

```js
const flatten = arr => arr.flat(Infinity);

console.log(flatten([1, [2, [3, 4], 5], 6])); // [1, 2, 3, 4, 5, 6]
```

Объяснения:

* Метод flat совершает обход массива массивов и превращает его структуру в плоскую (стремится к одномерному массиву).
* В качестве аргументов необходимо передать глубину обхода.
* В данном случае в качестве глубины обхода, я использовал Infinity, бесконечность, так как мне необходимо весь
  полученный массив превратить в
  одномерный массив.

Плюсы:

* Метод flat возвращает копию массива arr, массив arr не изменяется.
* Простое решение для превращения многомерных массивов в одномерные массивы.

Минусы:

* Зависит от современного API (Поддержка c ES2019)

### Использовать рекурсию

```js
const flatten = arr => [].concat(...arr.map(e => Array.isArray(e) ? flatten(e) : e));
```

Объяснения:

* Метод concat совершает объединение массивов и возвращает новый массив
* Метод map совершает обход массива и возвращает новый массив с измененными элементами
* Функция flatten будет вызываться до тех пор, пока условие `Array.isArray(e)` будет выполнятся

Плюсы:

* В результате выполнения рекурсивной функции будет возвращен новый одномерный массив
* Рекурсия ограничена размером вызовов

### Использовать рекурсию с reduce

```js
const flatten = arr => arr.reduce((result, current) => {
    if (Array.isArray(current)) {
        return result.concat(flatten(current));
    }

    result.push(current);

    return result;
}, []);
```

Объяснения:

* Метод reduce обходит массив и аккумулирует результат, в нашем случае, создает новый одномерный массив.
* Рекурсия будет выполняться до тех пор, пока будет выполняться условие `Array.isArray(current)`

### Использовать цикл while

```js
const flatten3 = arr => {
    const result = [];
    const stack = [...arr];

    while (stack.length) {
        const item = stack.pop();

        if (Array.isArray(item)) {
            stack.push(...item);
        } else {
            result.push(item);
        }
    }

    return result.reverse();
}
```

Эффективно для больших массивов, не рекурсивно (избегает переполнения стека вызовов)

### Задача 5. Асинхронность

Что выведется в консоль и почему?

```js
console.log('start');

setTimeout(() => {
    console.log('timeout');
}, 0);

Promise.resolve().then(() => {
    console.log('promise');
});

console.log('end');
```

Ожидаемый вывод:

```
start
end
promise
timeout
```

**Цель:** Проверка понимания Event Loop, микротасков и макротасков.

## Ответ

Event Loop - это механизм управления выполнения синхронного и асинхронного кода в однопоточной среде, на JavaScript в
среде выполнения Node.js и
в браузере. JavaScript выполняется в одном потоке, но благодаря Event Loop он может обрабатывать асинхронные операции,
такие как таймеры, события DOM, промисы и сетевые запросы, без блокирования основного потока.

Event Loop состоит из:

* Call Stack (Стек вызовов) - стек в котором, хранятся функции, которые выполняются в данный момент. Работает по
  принципу, последний пришел, первым ушел.
* Task queue (Очереди задачи) - очереди макрозадачи (setTimeout, EventListener (событие DOM), setInterval, fetch).
* Microtask queue (Очереди микрозадач) - очереди микрозадач (promise.then, queueMicrotask, MutationObserver).
* Render queue (Очереди на рендер UI) - очередь задач на рендинг UI (перерисовка страницы).
* WebAPIs в браузере (например setTimeout, fetch, DOM-события) обрабатываются вне основного потока, после выполнения,
  возвращает результат в очереди Microtask queue или Macrotask queue.

Как работает Event Loop:

1. JavaScript выполняет весь синхронный код в Call Stack
2. Когда встречается асинхронная операция (setTimeout, fetch, setInterval) она передается в Web APIs на выполнение.
3. После завершения асинхронных операций Web APIs передает результаты в соответствующие Task queue или Microtask queue.
4. Event Loop проверяет:
    * Если Call Stack пуст, сначала выполняются все микротаски из Microtask Queue.
    * Затем, если нужно, выполняется рендеринг (Render Queue)
    * После этого выполняет ода макротаска из Task Queue.

Этот процесс повторяется, пока очереди не опустеют.

Рассмотрим наш пример:

```js
console.log('start'); // Синхронный код выполняется сразу в Call Stack

setTimeout(() => {
    console.log('timeout');
}, 0); // Macrotask - передается на выполнение в Web APIs, после завершения результат будет отдан в очередь макрозадач.

Promise.resolve().then(() => {
    console.log('promise');
}); // Microtask - передается в очередь Microtasks

console.log('end'); // Синхронный код выполняется сразу в Call Stack
```

Результат:

```
start
end 
promise
timeout
```

```
Call Stack:
- console.log('start')   -> выполнен
- setTimeout(...)        -> передан в Web API (macrotask)
- Promise.then(...)      -> в Microtask Queue
- console.log('end')     -> выполнен

Затем:
Microtask Queue:
console.log('promise')

Потом:
Macrotask Queue:
console.log('timeout')
```