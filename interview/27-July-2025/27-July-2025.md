# 27 July 2025

Новый формат интервью: тестирование

## 1. Что выведет код?

```js
console.log(typeof null);
```

* A) "object"
* B) "null"
* C) "undefined"
* D) "function"

Ответ: **А)** object

```js
console.log(typeof null); // "object"
```

Объяснение: Этот баг в JavaScript с 1995 года, так и остался по сегодняшний день

## 2. Что произойдет?

```js
const arr = [1, 2, 3];

arr[10] = 5;
console.log(arr.length);
```

* A) 3
* B) 4
* C) 11
* D) 10

Ответ: **C)** 11

```js
const arr = [1, 2, 3];
arr[10] = 10;
console.log(arr); // [ 1, 2, 3, <7 empty items>, 10 ]
console.log(arr.length); // 11

arr.forEach(x => console.log(x)); // 1, 2, 3, 10

const filterArr = arr.filter(Boolean);
console.log(filterArr); // [1,2,3,10]

// or

for (let i = arr.length - 1; i >= 0; i--) {
    if (!arr[i]) {
        arr.splice(i, 1);
    }
}

console.log(arr); // 1,2,3,10
console.log(arr.length); // 4
```

Объяснение:

Так как последний индекс — 10, длина массива будет 11 (индекс + 1).

## 3. Что выведет этот код?

```js
let x = 1;

function test() {
    console.log(x);
    var x = 2;
}

test();
```

* A) 1
* B) 2
* C) undefined
* D) ReferenceError

Ответ: **С)** undefined

```js
let x = 1;

function test() {
    console.log(x);
    var x = 2;
}

test(); // undefined
```

Объяснение:

`var` ключевое слово, используемое в JS для объявления переменной до ES6.

Основное отличие от let и const в хостинге.
Поднятие переменной в let и const происходит в момент объявления.
При использовании var, поднятие переменной происходит до выполнения блока кода.

В блоке кода

```js
{
    console.log(x); // Переменная х поднята, но значение не задано, поэтому будет выведено undefined.
    var x = 2;
}
```

В блоке кода

```js
{
    console.log(x); // ReferenceError, переменной x можно пользоваться после поднятия.
    let x = 2;
}
```

## 4. Что такое "замыкание"? (closure)

* A) Функция, вызывающая другую функцию
* B) Способ замедления выполнения кода
* C) Функция, которая имеет доступ к переменным из внешней области даже после завершения этой области
* D) Ошибка синтаксиса

Ответ: **C)** Функция, которая имеет доступ к переменным из внешней области даже после завершения этой области

Объяснение:

```js
function color() {
    const colors = [
        '#cccccc', '#000000', '#ffffff'
    ];

    let lastIndex = 0;

    return function () {
        lastIndex = lastIndex + 1 === colors.length ? 0 : ++lastIndex;
        return colors[lastIndex];
    }
}

const getColor = color();

console.log(getColor());
console.log(getColor());
console.log(getColor());
console.log(getColor());
```

## 5. Что делает === в JS?

* A) Сравнивает значения без приведения типов
* B) Приводит типы и сравнивает
* C) Сравнивает только типы
* D) Приводит к boolean

Ответ: **A)** Сравнивает значения без приведения типов

Объяснение:

* === строгое сравнение без приведения типов.
* == сравнение с приведением типов.

## 6. Что выведется?

```js
Promise.resolve(1)
    .then(() => console.log('then'))
    .finally(() => console.log('finally'));
```

* A) 'finally', 'then'
* B) 'then', 'finally'
* C) 'then'
* D) 'finally'

Ответ: **B)** 'then', 'finally'

Объяснение:

Promise

* then() — используется для обработки успешного выполнения Promise
* catch() — для обработки ошибок
* finally() — выполняется вне зависимости от результата Promise (успех или ошибка)

Поэтому после выполнения then, будет выполнено finally.

## 7. Что делает this внутри обычной функции (не стрелочной)?

```js
function show() {
    console.log(this);
}

show();
```

* A) Всегда window
* B) Зависит от контекста вызова
* C) Всегда undefined
* D) Всегда объект функции

Ответ: **B)** Зависит от контекста вызова

Объяснение:

В `strict mode` будет `undefined`, в браузере - `window`.

## 8. Какой тип данных у NaN?

* A) "number"
* B) "NaN"
* C) "undefined"
* D) "object"

Ответ: **A)** "number"

Объяснение:

NaN - глобальное свойство, представляющим не число. (Not-A-Number)

Появляется к примеру, когда из строки пытаемся считать число.

```js
parseInt('hello world'); // NaN
```

Особенность языка JS - NaN считается числом.

## 9. Какой будет результат?

```js
[...'hello']
```

* A) ['hello']
* B) ['h', 'e', 'l', 'l', 'o']
* C) Ошибка
* D) undefined

Ответ: **B)** ['h', 'e', 'l', 'l', 'o']

Объяснение:

Spread-оператор разворачивает строку в массив символов.

## 10. Что делает оператор `??`?

* A) Возвращает первый falsy-элемент
* B) Возвращает первый truthy-элемент
* C) Возвращает правый операнд, если левый null или undefined
* D) Проверяет строгое равенство

Ответ: **C)** Возвращает правый операнд, если левый null или undefined

Объяснение:

Оператор `??` возвращает правый операнд, если левый null или undefined;

## 11. Что выведет код?

```js
let a = 1;

(function () {
    console.log(a);
    let a = 2;
})();
```

* A. 1
* B. 2
* C. undefined
* D. Ошибка (ReferenceError)

Ответ: `D.` Ошибка (ReferenceError)

Объяснение:

```js
(function () {
})();
```

В JavaScript выражение `(function () {})();` представляет собой анонимную самовызывающуюся функцию,
также известную как IIFE (Immediately Invoked Function Expression).

Это паттерн, который позволяет немедленно выполнить функцию после ее определения.
`(function () {})` заключают определение функции, а внутренние () вызывают ее немедленно.

```js
console.log(a);
let a = 2;
```

В момент выполнения `console.log(a)` переменная `a`, еще не была поднята. Поэтому обращение к ней вызывает ошибку
`ReferenceError`.

## 12. Какой будет результат?

```js
console.log([10] == 10);
```

* A. false
* B. true
* C. Ошибка
* D. undefined

Ответ: **B.** true

Объяснение:

Оператор `==` — равенство с приведением типов.

Операнд массив [10] будет преобразован в строку.

```js
[10].toString(); // "10"
```

Операнд 10 будет преобразован в строку.

```
10 -> "10"
```

```js
[10] == 10 // true
```

## 13. Что выведет этот код?

```js
class A {
    constructor() {
        this.value = 42;
    }

    getValue() {
        return this.value;
    }
}

class B extends A {
    constructor() {
        super();
        this.value = 100;
    }
}

const b = new B();
console.log(b.getValue());
```

* A. undefined
* B. 42
* C. 100
* D. Ошибка

Ответ: 

Объяснение:


## Задача

Ответ:

Объяснение: