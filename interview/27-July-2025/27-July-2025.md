# 27 July 2025

Новый формат интервью: тестирование

## 1. Что выведет код?

```js
console.log(typeof null);
```

* A) "object"
* B) "null"
* C) "undefined"
* D) "function"

Ответ: **А)** object

```js
console.log(typeof null); // "object"
```

Объяснение: Этот баг в JavaScript с 1995 года, так и остался по сегодняшний день

## 2. Что произойдет?

```js
const arr = [1, 2, 3];

arr[10] = 5;
console.log(arr.length);
```

* A) 3
* B) 4
* C) 11
* D) 10

Ответ: **C)** 11

```js
const arr = [1, 2, 3];
arr[10] = 10;
console.log(arr); // [ 1, 2, 3, <7 empty items>, 10 ]
console.log(arr.length); // 11

arr.forEach(x => console.log(x)); // 1, 2, 3, 10

const filterArr = arr.filter(Boolean);
console.log(filterArr); // [1,2,3,10]

// or

for (let i = arr.length - 1; i >= 0; i--) {
    if (!arr[i]) {
        arr.splice(i, 1);
    }
}

console.log(arr); // 1,2,3,10
console.log(arr.length); // 4
```

Объяснение:

Так как последний индекс — 10, длина массива будет 11 (индекс + 1).

## 3. Что выведет этот код?

```js
let x = 1;

function test() {
    console.log(x);
    var x = 2;
}

test();
```

* A) 1
* B) 2
* C) undefined
* D) ReferenceError

Ответ: **С)** undefined

```js
let x = 1;

function test() {
    console.log(x);
    var x = 2;
}

test(); // undefined
```

Объяснение:

`var` ключевое слово, используемое в JS для объявления переменной до ES6.

Основное отличие от let и const в хостинге.
Поднятие переменной в let и const происходит в момент объявления.
При использовании var, поднятие переменной происходит до выполнения блока кода.

В блоке кода

```js
{
    console.log(x); // Переменная х поднята, но значение не задано, поэтому будет выведено undefined.
    var x = 2;
}
```

В блоке кода

```js
{
    console.log(x); // ReferenceError, переменной x можно пользоваться после поднятия.
    let x = 2;
}
```

## 4. Что такое "замыкание"? (closure)

* A) Функция, вызывающая другую функцию
* B) Способ замедления выполнения кода
* C) Функция, которая имеет доступ к переменным из внешней области даже после завершения этой области
* D) Ошибка синтаксиса

Ответ: **C)** Функция, которая имеет доступ к переменным из внешней области даже после завершения этой области

Объяснение:

```js
function color() {
    const colors = [
        '#cccccc', '#000000', '#ffffff'
    ];

    let lastIndex = 0;

    return function () {
        lastIndex = lastIndex + 1 === colors.length ? 0 : ++lastIndex;
        return colors[lastIndex];
    }
}

const getColor = color();

console.log(getColor());
console.log(getColor());
console.log(getColor());
console.log(getColor());
```

## 5. Что делает === в JS?

* A) Сравнивает значения без приведения типов
* B) Приводит типы и сравнивает
* C) Сравнивает только типы
* D) Приводит к boolean

Ответ: **A)** Сравнивает значения без приведения типов

Объяснение:

* === строгое сравнение без приведения типов.
* == сравнение с приведением типов.

## 6. Что выведется?

```js
Promise.resolve(1)
    .then(() => console.log('then'))
    .finally(() => console.log('finally'));
```

* A) 'finally', 'then'
* B) 'then', 'finally'
* C) 'then'
* D) 'finally'

Ответ: **B)** 'then', 'finally'

Объяснение:

Promise

* then() — используется для обработки успешного выполнения Promise
* catch() — для обработки ошибок
* finally() — выполняется вне зависимости от результата Promise (успех или ошибка)

Поэтому после выполнения then, будет выполнено finally.

## 7. Что делает this внутри обычной функции (не стрелочной)?

```js
function show() {
    console.log(this);
}

show();
```

* A) Всегда window
* B) Зависит от контекста вызова
* C) Всегда undefined
* D) Всегда объект функции

Ответ: **B)** Зависит от контекста вызова

Объяснение:

В `strict mode` будет `undefined`, в браузере - `window`.

## 8. Какой тип данных у NaN?

* A) "number"
* B) "NaN"
* C) "undefined"
* D) "object"

Ответ: **A)** "number"

Объяснение:

NaN - глобальное свойство, представляющим не число. (Not-A-Number)

Появляется к примеру, когда из строки пытаемся считать число.

```js
parseInt('hello world'); // NaN
```

Особенность языка JS - NaN считается числом.

## 9. Какой будет результат?

```js
[...'hello']
```

* A) ['hello']
* B) ['h', 'e', 'l', 'l', 'o']
* C) Ошибка
* D) undefined

Ответ: **B)** ['h', 'e', 'l', 'l', 'o']

Объяснение:

Spread-оператор разворачивает строку в массив символов.

## 10. Что делает оператор `??`?

* A) Возвращает первый falsy-элемент
* B) Возвращает первый truthy-элемент
* C) Возвращает правый операнд, если левый null или undefined
* D) Проверяет строгое равенство

Ответ: **C)** Возвращает правый операнд, если левый null или undefined

Объяснение:

Оператор `??` возвращает правый операнд, если левый null или undefined;

## 11. Что выведет код?

```js
let a = 1;

(function () {
    console.log(a);
    let a = 2;
})();
```

* A. 1
* B. 2
* C. undefined
* D. Ошибка (ReferenceError)

Ответ: `D.` Ошибка (ReferenceError)

Объяснение:

```js
(function () {
})();
```

В JavaScript выражение `(function () {})();` представляет собой анонимную самовызывающуюся функцию,
также известную как IIFE (Immediately Invoked Function Expression).

Это паттерн, который позволяет немедленно выполнить функцию после ее определения.
`(function () {})` заключают определение функции, а внутренние () вызывают ее немедленно.

```js
console.log(a);
let a = 2;
```

В момент выполнения `console.log(a)` переменная `a`, еще не была поднята. Поэтому обращение к ней вызывает ошибку
`ReferenceError`.

## 12. Какой будет результат?

```js
console.log([10] == 10);
```

* A. false
* B. true
* C. Ошибка
* D. undefined

Ответ: **B.** true

Объяснение:

Оператор `==` — равенство с приведением типов.

Операнд массив [10] будет преобразован в строку.

```js
[10].toString(); // "10"
```

Операнд 10 будет преобразован в строку.

```
10 -> "10"
```

```js
[10] == 10 // true
```

## 13. Что выведет этот код?

```js
class A {
    constructor() {
        this.value = 42;
    }

    getValue() {
        return this.value;
    }
}

class B extends A {
    constructor() {
        super();
        this.value = 100;
    }
}

const b = new B();
console.log(b.getValue());
```

* A. undefined
* B. 42
* C. 100
* D. Ошибка

Ответ: **C.** 100

Объяснение:

Класс `B` наследует класс `А`.
В конструкторе класса `B`, `super()` - запустит выполнение конструктора класса `А`.
В конструкторе класса `А` будет задано значение свойство `value`. Затем свойство `value` будет переопределено в классе
`B`.

## 14. Что будет выведено в консоль?

```js
console.log(typeof typeof 1);
```

* A. "number"
* B. "string"
* C. "undefined"
* D. "object"

Ответ: **B.** "string"

Объяснение:

Тут важен приоритет операторов и порядок выполнения.

`typeof 1` вернет `"number"`.
`typeof "number"` вернет `"string"`.

## 15. Что делает следующий код?

```js
const a = {};
const b = {key: 'b'};
const c = {key: 'c'};

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

* A. 123
* B. 456
* C. undefined
* D. NaN

Ответ: **B.** 456

Объяснение:

Объекты b и c при приведении к ключу становятся "[object Object]". Один ключ, последнее значение перезаписывает первое.

## 16. Что будет результатом выполнения?

```js
Promise.resolve(1)
    .then(x => {
        console.log(x);
        return x + 1;
    })
    .finally(x => {
        console.log(x);
        return 100;
    })
    .then(x => {
        console.log(x);
    });
```

* A. 1, undefined, 100
* B. 1, undefined, 2
* C. 1, 100, 100
* D. 1, 2, 100

Ответ: **B.** 1, undefined, 2

Объяснение:

Порядок выполнение:

```
.then(x => {
    console.log(x); // 1
    return x + 1;
})
```

```
.finally(x => {
    console.log(x); // undefined
    return 100;
})
```

```
.then(x => {
    console.log(x); // 2
});
```

`finally` не принимает аргумент и не влияет на поток значений в promise, если не выбрасывает ошибку.

## 17. Что вернет эта функция?

```js
const func = () => {
    return {test: true};
};

console.log(typeof func());
```

* A. 'object'
* B. 'undefined'
* C. 'boolean'
* D. 'function'

Ответ: **A.** 'object'

Объяснение:

Важен приоритет и порядок выполнения.

```js
console.log(typeof func());
```

Произойдет вызов функции `func()` и будет возвращен результат `{test: true}`.

```js
typeof {test: true} // 'object'`
```

## 18. Что делает оператор void?

* A. Обнуляет переменную
* B. Удаляет свойство объекта
* C. Возвращает undefined
* D. Проверяет тип данных

Ответ: **C.** Возвращает undefined

Объяснение:

Оператор void всегда возвращает undefined.

## 19. Какой модификатор доступа присутствует в классе JS?

* A. private
* B. protected
* C. #
* D. readonly

Ответ: **C.** #

Объяснение:

В ECMAScript2022 было введено приватное поле в классе.
Чтобы описать приватное поле в классе, необходимо использовать модификатор `#`.

```js
class MyClass {
    #privateField;

    constructor(value) {
        this.#privateField = value;
    }
}
```

## 20. Что выведет код?

```js
let count = 0;

const inc = () => count++;

inc();
inc();
inc();

console.log(count);
```

* A. 3
* B. 2
* C. 0
* D. 1

Ответ: **A.** 3

Объяснение:

```js
let count = 0; // поднята переменная и присвоено значение 0

const inc = () => count++; // инкремент увеличивает значение переменной count на 1 после вызова

// так как в функции inc не поднята переменная count, переменную count будут искать выше в лексическом окружении.

inc(); // после выполнения count === 1 
inc(); // после выполнения count === 2 
inc(); // после выполнения count === 3

console.log(count); // 3
```

## 21. Что будет выведено в консоль?

```js
const sym1 = Symbol('desc');
const sym2 = Symbol('desc');

console.log(sym1 === sym2);
```

* A. true
* B. false
* C. TypeError
* D. undefined

Ответ: `B. false`

Объяснение:

Каждое значение, возвращенное Symbol, будет уникально.

## 22. Что делает Object.defineProperty по умолчанию с полем, если явно не указаны флаги?

```js
const obj = {};
Object.defineProperty(obj, 'key', {value: 42});
```

Какой из флагов будет true?

* A. writable
* B. configurable
* C. enumerable
* D. ни один из них

Ответ: **D.** ни один из них

Объяснение:

Метод `Object.defineProperty()` позволяет определить новое свойство объекта или изменить существующее, а также настроить
его атрибуты (дескрипторы).

```js
const obj = {};

// Определяем новое свойство 'name' со значением 'John' и атрибутом writable: false
Object.defineProperty(obj, 'name', {
    value: 'Simon',
    writable: false,
    configurable: true,
    enumerable: true
});
```

* **value** — значение свойства
    * Значение по умолчанию — undefined
* **writable** — определяет, можно ли изменять значение свойства
    * Значение по умолчанию — false
* **configurable** — определяет, можно ли изменять атрибуты
    * Значение по умолчанию — false
* **enumerable** — определяет, будет ли свойства отображаться при перечислении свойств (объекта в цикле for...in)
    * Значение по умолчанию — false

## 23. Что выведет этот код?

```js
const obj = {
    get value() {
        return Math.random();
    }
};

console.log(obj.value === obj.value);
```

* A. true
* B. false
* C. undefined
* D. TypeError

Ответ: **B.** false

Объяснение:

Оператор === строгого сравнения без приведения типа.

`Math.random()` - Возвращает псевдослучайное число с плавающей точкой, которое находится в диапазоне от 0 до 1. Никогда
не вернет 1.

Строгое сравнение псевдослучайных чисел с плавающей точкой от 0 до 1, результатом будет false.

## 24. Что произойдет?

```js
const obj = {name: 'Alex'};
const proxy = new Proxy(obj, {
    get(target, prop) {
        return prop in target ? target[prop] : 'Not Found';
    }
});

console.log(proxy.age);
```

* A. undefined
* B. TypeError
* C. 'Not Found'
* D. null

Ответ: **C.** 'Not Found'

Объяснение:

Proxy объект оборачивается вокруг другого объекта, может перехватывать (самостоятельно обрабатывать) разные действия с
ним, например чтение и запись и другие.

proxy.age вызовет get, но так как prop age отсутствует в объекте, будет возвращено Not found.

## 25. Что выведет следующий код?

```js
async function test() {
    console.log('1');
    await Promise.resolve();
    console.log('2');
}

test();
console.log('3');
```

* A. 1 3 2
* B. 1 2 3
* C. 3 1 2
* D. 2 1 3

Ответ: **A.** 1 3 2

Объяснение:

```js
async function test() {
    console.log('1');
    await Promise.resolve();
    console.log('2');
}

test();
console.log('3');
```

Произойдет вызов функции `test()`, что вызовет `console.log('1')`;

Далее будет создана микротаска `await Promise.resolve();`.

Синхронный код продолжит работу `console.log('3');`.

Далее выполнится микротаска и код будет продолжен внутри функции `test`.

Итог, будет следующий порядок:

```
1
3
2
```

## 26. Что вернёт typeof для генератора?

```js
function* gen() {
}

console.log(typeof gen());
```

* A. 'object'
* B. 'function'
* C. 'generator'
* D. 'undefined'

Ответ: **A.** 'object'

## 27. Что выведет этот код?

```js
const obj = {
    name: 'John',
    greet() {
        return `Hello, ${this.name}`;
    }
};

const greet = obj.greet;
console.log(greet());
```

* A. "Hello, John"
* B. "Hello, undefined"
* C. "Hello, [object Object]"
* D. Ошибка времени выполнения

Ответ: **B.** "Hello, undefined"

Объяснение:

Для `function` важен контекст вызова функции.

```js
console.log(greet()); // "Hello, undefined"
```

Так как функция greet() будет вызвана с контекстом глобального объекта, или с `undefined`, если работает в строгом
режиме.

Исправить можно простым использованием `.call`.

```js
console.log(greet.call(obj));
```

## 28. Что будет результатом?

```js
let x = 1;

function foo() {
    eval('x = 5');
}

foo();
console.log(x);
```

* A. 1
* B. 5
* C. undefined
* D. ReferenceError

Ответ: **B.** 5

Объяснение:

`eval` - опасная функция, выполняет код, проходящий со всеми привилегиями вызывателя.

`eval('x = 5');` найдет в родительском лексическом окружении поднятую переменную `x`, и изменит ее значение.

## 29. Что выведет код?

```js
setTimeout(() => console.log('timeout'), 0);

Promise.resolve().then(() => console.log('promise'));

queueMicrotask(() => console.log('microtask'));

console.log('sync');
```

* A. sync → timeout → microtask → promise
* B. sync → microtask → promise → timeout
* C. sync → promise → microtask → timeout
* D. sync → microtask → timeout → promise

Ответ: **C.** sync → promise → microtask → timeout

Объяснение:

Важно понимать, как работает Event Loop.

Макротаска будет отправлена в очередь Task Queue.
Будет ожидать выполнения синхронного кода и всех микротасок.

```js
setTimeout(() => console.log('timeout'), 0);
```

Микротаски будут отправлены в очередь Microtasks выполнены сразу после выполнения синхронного кода.

```js
Promise.resolve().then(() => console.log('promise'));
queueMicrotask(() => console.log('microtask'));
```

Синхронный код будет выполнен сразу

```js
console.log('sync');
```

Итог, код будет выполнен в следующем порядке.

```
sync
promise
microtask
timeout
```

## 30. Что делает Reflect?

* A. Управляет рендерингом
* B. Позволяет синхронно вызывать промисы
* C. Предоставляет методы для операций над объектами, как альтернатива Object.*
* D. Используется для создания DOM-элементов

Ответ: **C.** Предоставляет методы для операций над объектами, как альтернатива Object.*

Объяснение:

Объект Reflect в JavaScript предоставляет набор статических методов, которые соответствуют внутренним операциям
JavaScript, как чтение и запись свойств, вызов функций и другие.

Reflect делает работу с внутренними операциями JavaScript более удобной, безопасной и предсказуемой, особенно в
контексте использования Proxy.

## 31. 

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение:

## 31.

Ответ:

Объяснение: