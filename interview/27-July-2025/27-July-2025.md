# 27 July 2025

Новый формат интервью: тестирование

## 1. Что выведет код?

```js
console.log(typeof null);
```

* A) "object"
* B) "null"
* C) "undefined"
* D) "function"

Ответ: **А)** object

```js
console.log(typeof null); // "object"
```

Объяснение: Этот баг в JavaScript с 1995 года, так и остался по сегодняшний день

## 2. Что произойдет?

```js
const arr = [1, 2, 3];

arr[10] = 5;
console.log(arr.length);
```

* A) 3
* B) 4
* C) 11
* D) 10

Ответ: **C)** 11

```js
const arr = [1, 2, 3];
arr[10] = 10;
console.log(arr); // [ 1, 2, 3, <7 empty items>, 10 ]
console.log(arr.length); // 11

arr.forEach(x => console.log(x)); // 1, 2, 3, 10

const filterArr = arr.filter(Boolean);
console.log(filterArr); // [1,2,3,10]

// or

for (let i = arr.length - 1; i >= 0; i--) {
    if (!arr[i]) {
        arr.splice(i, 1);
    }
}

console.log(arr); // 1,2,3,10
console.log(arr.length); // 4
```

Объяснение:

Так как последний индекс — 10, длина массива будет 11 (индекс + 1).

## 3. Что выведет этот код?

```js
let x = 1;

function test() {
    console.log(x);
    var x = 2;
}

test();
```

* A) 1
* B) 2
* C) undefined
* D) ReferenceError

Ответ: **С)** undefined

```js
let x = 1;

function test() {
    console.log(x);
    var x = 2;
}

test(); // undefined
```

Объяснение:

`var` ключевое слово, используемое в JS для объявления переменной до ES6.

Основное отличие от let и const в хостинге.
Поднятие переменной в let и const происходит в момент объявления.
При использовании var, поднятие переменной происходит до выполнения блока кода.

В блоке кода

```js
{
    console.log(x); // Переменная х поднята, но значение не задано, поэтому будет выведено undefined.
    var x = 2;
}
```

В блоке кода

```js
{
    console.log(x); // ReferenceError, переменной x можно пользоваться после поднятия.
    let x = 2;
}
```

## 4. Что такое "замыкание"? (closure)

* A) Функция, вызывающая другую функцию
* B) Способ замедления выполнения кода
* C) Функция, которая имеет доступ к переменным из внешней области даже после завершения этой области
* D) Ошибка синтаксиса

Ответ: **C)** Функция, которая имеет доступ к переменным из внешней области даже после завершения этой области

Объяснение:

```js
function color() {
    const colors = [
        '#cccccc', '#000000', '#ffffff'
    ];

    let lastIndex = 0;

    return function () {
        lastIndex = lastIndex + 1 === colors.length ? 0 : ++lastIndex;
        return colors[lastIndex];
    }
}

const getColor = color();

console.log(getColor());
console.log(getColor());
console.log(getColor());
console.log(getColor());
```

## 5. Что делает === в JS?

* A) Сравнивает значения без приведения типов
* B) Приводит типы и сравнивает
* C) Сравнивает только типы
* D) Приводит к boolean

Ответ: **A)** Сравнивает значения без приведения типов

Объяснение:

* === строгое сравнение без приведения типов.
* == сравнение с приведением типов.

## 6. Что выведется?

```js
Promise.resolve(1)
    .then(() => console.log('then'))
    .finally(() => console.log('finally'));
```

* A) 'finally', 'then'
* B) 'then', 'finally'
* C) 'then'
* D) 'finally'

Ответ: **B)** 'then', 'finally'

Объяснение:

Promise

* then() — используется для обработки успешного выполнения Promise
* catch() — для обработки ошибок
* finally() — выполняется вне зависимости от результата Promise (успех или ошибка)

Поэтому после выполнения then, будет выполнено finally.

## 7. Что делает this внутри обычной функции (не стрелочной)?

```js
function show() {
    console.log(this);
}

show();
```

* A) Всегда window
* B) Зависит от контекста вызова
* C) Всегда undefined
* D) Всегда объект функции

Ответ: **B)** Зависит от контекста вызова

Объяснение:

В `strict mode` будет `undefined`, в браузере - `window`.

## 8. Какой тип данных у NaN?

* A) "number"
* B) "NaN"
* C) "undefined"
* D) "object"

Ответ: **A)** "number"

Объяснение:

NaN - глобальное свойство, представляющим не число. (Not-A-Number)

Появляется к примеру, когда из строки пытаемся считать число.

```js
parseInt('hello world'); // NaN
```

Особенность языка JS - NaN считается числом.

## 9. Какой будет результат?

```js
[...'hello']
```

* A) ['hello']
* B) ['h', 'e', 'l', 'l', 'o']
* C) Ошибка
* D) undefined

Ответ: **B)** ['h', 'e', 'l', 'l', 'o']

Объяснение:

Spread-оператор разворачивает строку в массив символов.

## 10. Что делает оператор `??`?

* A) Возвращает первый falsy-элемент
* B) Возвращает первый truthy-элемент
* C) Возвращает правый операнд, если левый null или undefined
* D) Проверяет строгое равенство

Ответ: **C)** Возвращает правый операнд, если левый null или undefined

Объяснение:

Оператор `??` возвращает правый операнд, если левый null или undefined;

## 11. Что выведет код?

```js
let a = 1;

(function () {
    console.log(a);
    let a = 2;
})();
```

* A. 1
* B. 2
* C. undefined
* D. Ошибка (ReferenceError)

Ответ: `D.` Ошибка (ReferenceError)

Объяснение:

```js
(function () {
})();
```

В JavaScript выражение `(function () {})();` представляет собой анонимную самовызывающуюся функцию,
также известную как IIFE (Immediately Invoked Function Expression).

Это паттерн, который позволяет немедленно выполнить функцию после ее определения.
`(function () {})` заключают определение функции, а внутренние () вызывают ее немедленно.

```js
console.log(a);
let a = 2;
```

В момент выполнения `console.log(a)` переменная `a`, еще не была поднята. Поэтому обращение к ней вызывает ошибку
`ReferenceError`.

## 12. Какой будет результат?

```js
console.log([10] == 10);
```

* A. false
* B. true
* C. Ошибка
* D. undefined

Ответ: **B.** true

Объяснение:

Оператор `==` — равенство с приведением типов.

Операнд массив [10] будет преобразован в строку.

```js
[10].toString(); // "10"
```

Операнд 10 будет преобразован в строку.

```
10 -> "10"
```

```js
[10] == 10 // true
```

## 13. Что выведет этот код?

```js
class A {
    constructor() {
        this.value = 42;
    }

    getValue() {
        return this.value;
    }
}

class B extends A {
    constructor() {
        super();
        this.value = 100;
    }
}

const b = new B();
console.log(b.getValue());
```

* A. undefined
* B. 42
* C. 100
* D. Ошибка

Ответ: **C.** 100

Объяснение:

Класс `B` наследует класс `А`.
В конструкторе класса `B`, `super()` - запустит выполнение конструктора класса `А`.
В конструкторе класса `А` будет задано значение свойство `value`. Затем свойство `value` будет переопределено в классе
`B`.

## 14. Что будет выведено в консоль?

```js
console.log(typeof typeof 1);
```

* A. "number"
* B. "string"
* C. "undefined"
* D. "object"

Ответ: **B.** "string"

Объяснение:

Тут важен приоритет операторов и порядок выполнения.

`typeof 1` вернет `"number"`.
`typeof "number"` вернет `"string"`.

## 15. Что делает следующий код?

```js
const a = {};
const b = {key: 'b'};
const c = {key: 'c'};

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

* A. 123
* B. 456
* C. undefined
* D. NaN

Ответ: **B.** 456

Объяснение:

Объекты b и c при приведении к ключу становятся "[object Object]". Один ключ, последнее значение перезаписывает первое.

## 16. Что будет результатом выполнения?

```js
Promise.resolve(1)
    .then(x => {
        console.log(x);
        return x + 1;
    })
    .finally(x => {
        console.log(x);
        return 100;
    })
    .then(x => {
        console.log(x);
    });
```

* A. 1, undefined, 100
* B. 1, undefined, 2
* C. 1, 100, 100
* D. 1, 2, 100

Ответ: **B.** 1, undefined, 2

Объяснение:

Порядок выполнение:

```
.then(x => {
    console.log(x); // 1
    return x + 1;
})
```

```
.finally(x => {
    console.log(x); // undefined
    return 100;
})
```

```
.then(x => {
    console.log(x); // 2
});
```

`finally` не принимает аргумент и не влияет на поток значений в promise, если не выбрасывает ошибку.

## 17. Что вернет эта функция?

```js
const func = () => {
    return {test: true};
};

console.log(typeof func());
```

* A. 'object'
* B. 'undefined'
* C. 'boolean'
* D. 'function'

Ответ: **A.** 'object'

Объяснение:

Важен приоритет и порядок выполнения.

```js
console.log(typeof func());
```

Произойдет вызов функции `func()` и будет возвращен результат `{test: true}`.

```js
typeof {test: true} // 'object'`
```

## 18. Что делает оператор void?

* A. Обнуляет переменную
* B. Удаляет свойство объекта
* C. Возвращает undefined
* D. Проверяет тип данных

Ответ: **C.** Возвращает undefined

Объяснение:

Оператор void всегда возвращает undefined.

## 19. Какой модификатор доступа присутствует в классе JS?

* A. private
* B. protected
* C. #
* D. readonly

Ответ: **C.** #

Объяснение:

В ECMAScript2022 было введено приватное поле в классе.
Чтобы описать приватное поле в классе, необходимо использовать модификатор `#`.

```js
class MyClass {
    #privateField;

    constructor(value) {
        this.#privateField = value;
    }
}
```

## 20. Что выведет код?

```js
let count = 0;

const inc = () => count++;

inc();
inc();
inc();

console.log(count);
```

* A. 3
* B. 2
* C. 0
* D. 1

Ответ: **A.** 3

Объяснение:

```js
let count = 0; // поднята переменная и присвоено значение 0

const inc = () => count++; // инкремент увеличивает значение переменной count на 1 после вызова

// так как в функции inc не поднята переменная count, переменную count будут искать выше в лексическом окружении.

inc(); // после выполнения count === 1 
inc(); // после выполнения count === 2 
inc(); // после выполнения count === 3

console.log(count); // 3
```