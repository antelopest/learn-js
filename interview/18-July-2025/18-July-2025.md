# 18 July 2025

## Вопрос 2 - Разница между debounce и throttle

`Debounce` и `throttle` - это техники для ограничения частоты выполнения функции,
часто используемые при обработке событий, таких как scroll, resize, input или mousemove.
Однако они работают по-разному и применяются в разных сценариях.

1. Debounce (Дебаунсинг)
2. Throttle (Троттлинг)

### Что делает:

Ограничивает частоту выполнения функции, гарантируя, что она вызывается не чаще, чем раз в заданный период времени (
delay),
даже если события происходят чаще.

### Как работает

* Функция выполняется немедленно при первом вызове (или после истечения delay), а последующие вызовы игнорируются, пока
  не пройдет delay.
* После истечения delay функция может быть вызвана снова при следующем событии

Ключевой момент: Функция выполняется с регулярными интервалами, даже если события происходят непрерывно.

#### Пример:

```js
function log(message) {
  console.log(message);
}

function throttle(func, delay) {
  let isThrottled = false;

  return function (...args) {
    if (isThrottled) return;

    isThrottled = true;
    func.apply(this, args); // Выполняется немедленно

    setTimeout(() => {
      isThrottled = false;
    }, delay);
  };
}

const throttledLog = throttle(log, 1000);
throttledLog("Hello"); // Выполнится сразу: "Hello"
throttledLog("Hello again"); // Игнорируется
setTimeout(() => throttledLog("Hello final"), 1500); // Выполнится через 1.5 секунды: "Hello final"
```

## Вопрос 3 - Практика

### Задача

Напиши функцию **debounce**, которая принимает функцию и задержку (в миллисекундах) и возвращает новую функцию, которая
выполняется не чаще, чем раз в указанную задержку. Это часто используется для ограничения частоты вызовов, например, при
обработке событий `scroll` или `resize`.

Напишите функцию debounce, которая:

* Принимает функцию (func) и задержку в миллисекундах (delay).
* Возвращает новую функцию, которая:
    * Выполняет func только один раз за указанный период delay, игнорируя все промежуточные вызовы.
    * Выполняет последний вызов функции, если она вызывалась многократно в течение delay.
    * Поддерживает передачу любых аргументов и контекста this в исходную функцию.
* Код должен быть читаемым и универсальным.

```js
function log(message) {
    console.log(message);
}

function debounce(func, delay) {

    let timeoutId;

    return function (...args) {

        clearTimeout(timeoutId);

        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    }
}

const debouncedLog = debounce(log, 1000);

debouncedLog("Hello"); // Игнорируется
debouncedLog("Hello again"); // Будет вызвано, так как вызвано последним

const obj = {
    name: "Test", log: function (msg) {
        console.log(this.name, msg);
    }
};
const debounced = debounce(obj.log, 1000);
debounced.call(obj, "Hello"); // Через 1 секунду: "Test Hello"
```

## Ответ

```js
function log(message) {
    console.log(message);
}

function debounce(func, delay) {

    let isDone = false;

    return function (message) {
        if (isDone) return;

        isDone = true;

        setTimeout(function () {
            func(message);

            isDone = false;
        }, delay);
    }
}

const debouncedLog = debounce(log, 1000);

debouncedLog("Hello"); // Выполнится через 1 секунду
debouncedLog("Hello again"); // Игнорируется, так как вызвано в течение 1 секунды
```

## Вопрос 5 - Практика

### Задача:

Напиши функцию **deepClone**, которая создаёт глубокую копию объекта или массива (включая вложенные объекты и массивы).
Функция должна корректно копировать примитивы, объекты, массивы и учитывать циклические ссылки.

```js
const obj = {
    a: 1,
    b: {c: 2, d: [3, 4]},
    e: null
};

const cloned = deepClone(obj);
console.log(cloned); // { a: 1, b: { c: 2, d: [3, 4] }, e: null }
console.log(cloned !== obj); // true
console.log(cloned.b !== obj.b); // true
console.log(cloned.b.d !== obj.b.d); // true
```

### Ответ

#### Решение с использованием JSON (parse, stringify)

```js
const deepClone = (obj) => {
    const json = JSON.stringify(obj);
    return JSON.parse(json);
}

const cloned = deepClone(obj);
```

#### Проблемы:

* Отсутствие обработки циклических ссылок

```js
const obj = {a: 1};
obj.self = obj;

JSON.stringify(obj); // Ошибка: "Converting circular structure to JSON"
```

> `JSON.stringify` - имеет ограничения:
>
> Некоторые типы теряются при сериализации
> * функции игнорируются `{ fn: () => {} }`
> * объекты Date преобразуются в строки
> * `undefined`, `NaN`, `Infinity` преобразуются в null
> * объекты с нестандартными типами (например `Map` и `Set`) не поддерживаются

* Производительность

Для больших объектов `JSON.stringify` и `JSON.parse` могут быть медленнее, чем рекурсивное копирование, так как требуют
сериализации и десериализации.

#### Решение с использованием рекурсии

```js
const deepClone1 = (obj) => {

    const isPrimitive = value => {
        return value === null || (typeof value !== 'object' && typeof value !== 'function');
    }

    const isArray = value => {
        return Array.isArray(value);
    }

    if (isPrimitive(obj)) return obj;

    const result = isArray(obj) ? [] : {};

    for (let key in obj) {
        result[key] = deepClone1(obj[key]);
    }

    return result;
}
```

#### Проблемы:

* Отсутствие обработки циклических ссылок

```js
const obj = {a: 1};
obj.self = obj;
deepClone1(obj); // Ошибка: Maximum call stack size exceeded
```

Без механизма отслеживания уже скопированных объектов рекурсия уходит в бесконечный цикл.

* Ограниченная обработка типов

Код не учитывает специальные типы данных, такие как `Date`, `Map`, `Set`, `RegExp`,
которые требуют особого копирования.

* `Date` копируется как объект, а не как новый экземпляр Date.
* `Map`, `Set` копируются как обычные объекты, теряя свои методы.

* Использование `for...in` цикла

Цикл `for...in` перебирает все перечисляемые свойства, включая унаследованные от прототипа.
Это может привести к неожиданным результатам, если объект имеет нестандартные прототипы. Лучше использовать Object.keys
и проверку `hasOwnProperty`.

* Отсутствие обработки функций

Если в объекте есть функции, они копируются как есть, но это может быть нежелательно, так как функции могут зависеть от
контекста.

### Почему ответ был некорректный:

Некорректно интерпретировал все условия задачи, пропустил условие, при которых необходимо копировать не только
примитивы,
объекты и массивы, но и **цикличные ссылки**.

## Исправленное решение с учетом циклических ссылок

Чтобы полностью соответствовать требованиям задачи, нужно добавить обработку циклических ссылок с использованием,
например,
`WeakMap` для отслеживания уже скопированных объектов.

```js
const deepClone = (obj, seen = new WeakMap()) => {
    // Проверяем примитивы
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    // Проверяем циклические ссылки
    if (seen.has(obj)) {
        return seen.get(obj);
    }

    // Создаём новый объект или массив
    const result = Array.isArray(obj) ? [] : {};

    // Сохраняем объект в WeakMap перед рекурсией
    seen.set(obj, result);

    // Перебираем только собственные свойства
    for (const key of Object.keys(obj)) {
        result[key] = deepClone(obj[key], seen);
    }

    return result;
};
```