# 18 July 2025

## Вопрос 1 - Контекст и `this`

`this` в JavaScript - это ключевое слово, которое ссылается на контекст выполнения функции, то есть на объект, к
которому привязана функция во время ее вызова. Значение this определяется динамически в момент вызова функции и зависит
от того, как и где она вызывается.
Основное правило: this указывает на объект, который владеет функцией в момент ее выполнения, но есть исключения,
особенно для стрелочный функций.

* В обычной функции
    * В обычной функции (объявленной через function) значение this зависит от того, как функция вызвана:
        * Вне объекта (глобальный контекст): Если функция вызывается без привязки к объекту, this указывается на
          глобальный объект (window в браузере или globalThis в Node.js). В строгом режиме ("use strict") this будет
          undefined.
        * Привязка через вызов: Если функция вызвана как метод объекта, this указывает на этот объект.

```js
function regularFunction() {
    console.log(this);
}

regularFunction(); // in browser return window or in node.js return globalThis

'use strict';
regularFunction(); // in strong mode return undefined

const obj = {
    name: "Test",
    method: regularFunction
};

obj.method(); // { name: "Test", method: regularFunction }
```

* В стрелочной функции
    * Стрелочные функции (() => {}) не имеют собственного this. Вместо этого они лексически захватывают this из
      окружающей области видимости (той, где функция определена). Это делает их поведение предсказуемым, но менее гибким
      для динамической привязки.
    * Значение this в стрелочной функции не зависит от того, как оно вызвана, а берется из контекста, в котором функция
      была создана.

```js
const obj = {
    name: "Test",
    regular: function () {
        console.log(this.name)
    },
    arrow: () => {
        console.log(this.name)
    }
}

obj.regular(); // Test
obj.arrow(); // undefined

const outerThis = this;
const outer = {
    name: "Outer",
    inner: () => {
        console.log(this === outerThis);
    }
};

outer.inner(); // true
```

* В методе объекта:
    * Когда функция является методом объекта (определена как свойство объекта), this внутри нее указывает на сам
      объект при вызове через obj.method().
    * Если метод "отрывается" от объекта, this может потерять привязку.

```js
const obj = {
    name: "Test",
    method: function () {
        console.log(this.name);
    }
}

obj.method(); // Test (this = obj)

const detached = obj.method();

detached(); // global object window (in browser) or globalThis (node.js)

'use strict';

detached(); // undefined
```

* В обработчике событий
    * В обработчиках событий (например, через addEventListener) значение this зависит от того, как функция привязана:
        * В обычной функции this обычно указывает на элемент, вызвавший событие (например, DOM-элемент).
        * В стрелочной функции this берется из лексического контекста, где функция определена, а не из DOM-элемента.

```js
const button = document.querySelector("button");

button.addEventListener('click', function () {
    console.log(this); // <button> - элемент, вызвавший событие
});

button.addEventListener('click', () => {
    console.log(this); // window/globalThis 
});

const obj = {
    name: "Test",
    handleClick: function () {
        console.log(this.name);
    }
}

button.addEventListener('click', obj.handleClick.bind(obj)); // Test
```

Ключевые моменты:
* Обычные функции: this определяется в момент вызова и зависит от контекста (объект, глобальный объект, undefined в строгом режиме).
* Стрелочные функции: this фиксируется при определении функции и берется из окружающей области.
* Методы объекта: this указывает на объект, если метод вызывается через него.
* Обработчик событий: this обычно указывает на DOM-элемент в обычных функциях, но в стрелочный - на лексический контекст.
* Можно управлять this с помощью методов call, apply, bind.

## Вопрос 2 — Разница между debounce и throttle

`Debounce` и `throttle` - это техники для ограничения частоты выполнения функции,
часто используемые при обработке событий, таких как scroll, resize, input или mousemove.
Однако они работают по-разному и применяются в разных сценариях.

1. Debounce (Дебаунсинг)

### Что делает:

Группирует несколько последовательных вызовов функции в один, выполняя только последний вызов после того, как события
прекратятся на заданный период времени (`delay`).

### Как работает

* Каждый новый вызов функции сбрасывает таймер
* Функция выполняется только после того, как проходит `delay` миллисекунд без новых вызовов.

Ключевой момент: Если события происходят часто, функция будет выполнена только один раз - после последнего события,
когда наступим пауза

#### Пример:

```js
function log(message) {
    console.log(message);
}

function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

const debouncedLog = debounce(log, 1000);
debouncedLog("Hello"); // Игнорируется
debouncedLog("Hello again"); // Игнорируется
debouncedLog("Hello final"); // Выполнится через 1 секунду: "Hello final"
```

2. Throttle (Троттлинг)

### Что делает:

Ограничивает частоту выполнения функции, гарантируя, что она вызывается не чаще, чем раз в заданный период времени (
delay),
даже если события происходят чаще.

### Как работает

* Функция выполняется немедленно при первом вызове (или после истечения delay), а последующие вызовы игнорируются, пока
  не пройдет delay.
* После истечения delay функция может быть вызвана снова при следующем событии

Ключевой момент: Функция выполняется с регулярными интервалами, даже если события происходят непрерывно.

#### Пример:

```js
function log(message) {
    console.log(message);
}

function throttle(func, delay) {
    let isThrottled = false;

    return function (...args) {
        if (isThrottled) return;

        isThrottled = true;
        func.apply(this, args); // Выполняется немедленно

        setTimeout(() => {
            isThrottled = false;
        }, delay);
    };
}

const throttledLog = throttle(log, 1000);
throttledLog("Hello"); // Выполнится сразу: "Hello"
throttledLog("Hello again"); // Игнорируется
setTimeout(() => throttledLog("Hello final"), 1500); // Выполнится через 1.5 секунды: "Hello final"
```

## Вопрос 3 — Практика

### Задача

Напиши функцию **debounce**, которая принимает функцию и задержку (в миллисекундах) и возвращает новую функцию, которая
выполняется не чаще, чем раз в указанную задержку. Это часто используется для ограничения частоты вызовов, например, при
обработке событий `scroll` или `resize`.

Напишите функцию debounce, которая:

* Принимает функцию (func) и задержку в миллисекундах (delay).
* Возвращает новую функцию, которая:
    * Выполняет func только один раз за указанный период delay, игнорируя все промежуточные вызовы.
    * Выполняет последний вызов функции, если она вызывалась многократно в течение delay.
    * Поддерживает передачу любых аргументов и контекста this в исходную функцию.
* Код должен быть читаемым и универсальным.

```js
function log(message) {
    console.log(message);
}

function debounce(func, delay) {

    let timeoutId;

    return function (...args) {

        clearTimeout(timeoutId);

        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    }
}

const debouncedLog = debounce(log, 1000);

debouncedLog("Hello"); // Игнорируется
debouncedLog("Hello again"); // Будет вызвано, так как вызвано последним

const obj = {
    name: "Test", log: function (msg) {
        console.log(this.name, msg);
    }
};
const debounced = debounce(obj.log, 1000);
debounced.call(obj, "Hello"); // Через 1 секунду: "Test Hello"
```

## Ответ

```js
function log(message) {
    console.log(message);
}

function debounce(func, delay) {

    let isDone = false;

    return function (message) {
        if (isDone) return;

        isDone = true;

        setTimeout(function () {
            func(message);

            isDone = false;
        }, delay);
    }
}

const debouncedLog = debounce(log, 1000);

debouncedLog("Hello"); // Выполнится через 1 секунду
debouncedLog("Hello again"); // Игнорируется, так как вызвано в течение 1 секунды
```

## Вопрос 5 — Практика

### Задача:

Напиши функцию **deepClone**, которая создаёт глубокую копию объекта или массива (включая вложенные объекты и массивы).
Функция должна корректно копировать примитивы, объекты, массивы и учитывать циклические ссылки.

```js
const obj = {
    a: 1,
    b: {c: 2, d: [3, 4]},
    e: null
};

const cloned = deepClone(obj);
console.log(cloned); // { a: 1, b: { c: 2, d: [3, 4] }, e: null }
console.log(cloned !== obj); // true
console.log(cloned.b !== obj.b); // true
console.log(cloned.b.d !== obj.b.d); // true
```

### Ответ

#### Решение с использованием JSON (parse, stringify)

```js
const deepClone = (obj) => {
    const json = JSON.stringify(obj);
    return JSON.parse(json);
}

const cloned = deepClone(obj);
```

#### Проблемы:

* Отсутствие обработки циклических ссылок

```js
const obj = {a: 1};
obj.self = obj;

JSON.stringify(obj); // Ошибка: "Converting circular structure to JSON"
```

> `JSON.stringify` - имеет ограничения:
>
> Некоторые типы теряются при сериализации
> * функции игнорируются `{ fn: () => {} }`
> * объекты Date преобразуются в строки
> * `undefined`, `NaN`, `Infinity` преобразуются в null
> * объекты с нестандартными типами (например `Map` и `Set`) не поддерживаются

* Производительность

Для больших объектов `JSON.stringify` и `JSON.parse` могут быть медленнее, чем рекурсивное копирование, так как требуют
сериализации и десериализации.

#### Решение с использованием рекурсии

```js
const deepClone1 = (obj) => {

    const isPrimitive = value => {
        return value === null || (typeof value !== 'object' && typeof value !== 'function');
    }

    const isArray = value => {
        return Array.isArray(value);
    }

    if (isPrimitive(obj)) return obj;

    const result = isArray(obj) ? [] : {};

    for (let key in obj) {
        result[key] = deepClone1(obj[key]);
    }

    return result;
}
```

#### Проблемы:

* Отсутствие обработки циклических ссылок

```js
const obj = {a: 1};
obj.self = obj;
deepClone1(obj); // Ошибка: Maximum call stack size exceeded
```

Без механизма отслеживания уже скопированных объектов рекурсия уходит в бесконечный цикл.

* Ограниченная обработка типов

Код не учитывает специальные типы данных, такие как `Date`, `Map`, `Set`, `RegExp`,
которые требуют особого копирования.

* `Date` копируется как объект, а не как новый экземпляр Date.
* `Map`, `Set` копируются как обычные объекты, теряя свои методы.

* Использование `for...in` цикла

Цикл `for...in` перебирает все перечисляемые свойства, включая унаследованные от прототипа.
Это может привести к неожиданным результатам, если объект имеет нестандартные прототипы. Лучше использовать Object.keys
и проверку `hasOwnProperty`.

* Отсутствие обработки функций

Если в объекте есть функции, они копируются как есть, но это может быть нежелательно, так как функции могут зависеть от
контекста.

### Почему ответ был некорректный:

Некорректно интерпретировал все условия задачи, пропустил условие, при которых необходимо копировать не только
примитивы,
объекты и массивы, но и **цикличные ссылки**.

## Исправленное решение с учетом циклических ссылок

Чтобы полностью соответствовать требованиям задачи, нужно добавить обработку циклических ссылок с использованием,
например,
`WeakMap` для отслеживания уже скопированных объектов.

```js
const deepClone = (obj, seen = new WeakMap()) => {
    // Проверяем примитивы
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    // Проверяем циклические ссылки
    if (seen.has(obj)) {
        return seen.get(obj);
    }

    // Создаём новый объект или массив
    const result = Array.isArray(obj) ? [] : {};

    // Сохраняем объект в WeakMap перед рекурсией
    seen.set(obj, result);

    // Перебираем только собственные свойства
    for (const key of Object.keys(obj)) {
        result[key] = deepClone(obj[key], seen);
    }

    return result;
};
```