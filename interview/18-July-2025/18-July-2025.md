# 18 July 2025

## Вопрос 5 - Практика

### Задача:

Напиши функцию **deepClone**, которая создаёт глубокую копию объекта или массива (включая вложенные объекты и массивы).
Функция должна корректно копировать примитивы, объекты, массивы и учитывать циклические ссылки.

```js
const obj = {
    a: 1,
    b: {c: 2, d: [3, 4]},
    e: null
};

const cloned = deepClone(obj);
console.log(cloned); // { a: 1, b: { c: 2, d: [3, 4] }, e: null }
console.log(cloned !== obj); // true
console.log(cloned.b !== obj.b); // true
console.log(cloned.b.d !== obj.b.d); // true
```

## Ответ

### Решение с использованием JSON (parse, stringify)

```js
const deepClone = (obj) => {
    const json = JSON.stringify(obj);
    return JSON.parse(json);
}

const cloned = deepClone(obj);
```

#### Проблемы:

* Отсутствие обработки циклических ссылок

```js
const obj = {a: 1};
obj.self = obj;

JSON.stringify(obj); // Ошибка: "Converting circular structure to JSON"
```

> `JSON.stringify` - имеет ограничения:
>
> Некоторые типы теряются при сериализации
> * функции игнорируются `{ fn: () => {} }`
> * объекты Date преобразуются в строки
> * `undefined`, `NaN`, `Infinity` преобразуются в null
> * объекты с нестандартными типами (например `Map` и `Set`) не поддерживаются

* Производительность

Для больших объектов `JSON.stringify` и `JSON.parse` могут быть медленнее, чем рекурсивное копирование, так как требуют
сериализации и десериализации.

### Решение с использованием рекурсии

```js
const deepClone1 = (obj) => {

    const isPrimitive = value => {
        return value === null || (typeof value !== 'object' && typeof value !== 'function');
    }

    const isArray = value => {
        return Array.isArray(value);
    }

    if (isPrimitive(obj)) return obj;

    const result = isArray(obj) ? [] : {};

    for (let key in obj) {
        result[key] = deepClone1(obj[key]);
    }

    return result;
}
```

#### Проблемы:

* Отсутствие обработки циклических ссылок

```js
const obj = {a: 1};
obj.self = obj;
deepClone1(obj); // Ошибка: Maximum call stack size exceeded
```

Без механизма отслеживания уже скопированных объектов рекурсия уходит в бесконечный цикл.

* Ограниченная обработка типов

Код не учитывает специальные типы данных, такие как `Date`, `Map`, `Set`, `RegExp`,
которые требуют особого копирования.

* `Date` копируется как объект, а не как новый экземпляр Date.
* `Map`, `Set` копируются как обычные объекты, теряя свои методы.

* Использование `for...in` цикла

Цикл `for...in` перебирает все перечисляемые свойства, включая унаследованные от прототипа.
Это может привести к неожиданным результатам, если объект имеет нестандартные прототипы. Лучше использовать Object.keys
и проверку `hasOwnProperty`.

* Отсутствие обработки функций

Если в объекте есть функции, они копируются как есть, но это может быть нежелательно, так как функции могут зависеть от
контекста.

### Почему ответ был некорректный:

Некорректно интерпретировал все условия задачи, пропустил условие, при которых необходимо копировать не только
примитивы,
объекты и массивы, но и **цикличные ссылки**.

## Исправленное решение с учетом циклических ссылок 

Чтобы полностью соответствовать требованиям задачи, нужно добавить обработку циклических ссылок с использованием, например, 
`WeakMap` для отслеживания уже скопированных объектов.

```js
const deepClone = (obj, seen = new WeakMap()) => {
    // Проверяем примитивы
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    // Проверяем циклические ссылки
    if (seen.has(obj)) {
        return seen.get(obj);
    }

    // Создаём новый объект или массив
    const result = Array.isArray(obj) ? [] : {};

    // Сохраняем объект в WeakMap перед рекурсией
    seen.set(obj, result);

    // Перебираем только собственные свойства
    for (const key of Object.keys(obj)) {
        result[key] = deepClone(obj[key], seen);
    }

    return result;
};
```