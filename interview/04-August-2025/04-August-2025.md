__# 4 August 2025

## Вопросы:

1. **HTML:** Что такое семантический HTML, и почему он важен? Приведи пример семантического элемента.
2. **HTML:** Как работает атрибут `data-*` в HTML? Приведи пример использования.
3. **CSS:** Объясни разницу между `relative`, `absolute`, `fixed` и `sticky` позиционированием в CSS.
4. **CSS:** Что такое псевдоклассы и псевдоэлементы? Приведи примеры.
5. **CSS:** Как работает flexbox? Опиши свойства `justify-content` и `align-items`.
6. **JavaScript:** Что такое замыкания (`closures`) в JavaScript? Приведи пример.
7. **JavaScript:** Объясни разницу между `var`, `let` и `const`.
8. **JavaScript:** Что такое асинхронное программирование? Как работают `Promises` и `async/await`?
9. **HTML/CSS/JS:** Как бы ты оптимизировал загрузку веб-страницы? Назови минимум 3 способа.
10. **JavaScript:** Что такое делегация событий? Приведите пример кода.

## Подробные ответы:

### 1. **HTML:** Что такое семантический HTML, и почему он важен? Приведи пример семантического элемента.

Семантический HTML — это использование тегов, которые имеют смысловое значение (семантику), описывающее содержимое, а не
только его внешний вид.

#### Зачем он нужен:

1. Улучшает доступность: экранные читалки (для людей с нарушениями зрения) лучше понимают структуру страницы.
2. Упрощает SEO: поисковые системы легче распознают важные части страницы.
3. Повышает читаемость кода: другим разработчикам проще понимать структуру HTML.
4. Лучше для поддержки и масштабирования: можно легче работать в команде и поддерживать проект.

#### Пример семантических тегов:

| Тег                         | Назначение                              |
|-----------------------------|-----------------------------------------|
| `<header>`                  | Заголовок страницы или секции           |
| `<nav>`                     | Навигация по сайту                      |
| `<main>`                    | Основной контент страницы               |
| `<section>`                 | Раздел внутри контента                  |
| `<article>`                 | Независимый блок (например, статья)     |
| `<aside>`                   | Боковая информация, не основной контент |
| `<footer>`                  | Нижняя часть страницы/раздела           |
| `<figure>` / `<figcaption>` | Медиа и подписи к ним                   |
| `<mark>`                    | Выделение текста                        |
| `<time>`                    | Отметка времени                         |

#### Пример

```html

<main>
    <article>
        <header>
            <h1>Как работает JavaScript</h1>
            <p>Автор: Алексей</p>
        </header>
        <section>
            <h2>Что такое интерпретатор?</h2>
            <p>JavaScript выполняется интерпретатором браузера...</p>
        </section>
        <footer>
            <p>Опубликовано
                <time datetime="2025-08-05">5 августа 2025</time>
            </p>
        </footer>
    </article>
</main>
```

### 2. **HTML:** Как работает атрибут `data-*` в HTML? Приведи пример использования.

Атрибуты `data-*` - это пользовательские атрибуты, с помощью которых можно сохранять произвольные данные в
HTML-элементах.
Они не влияют на отображение, но позволяют удобно передавать данные в JavaScript.

```html

<div data-user-id="123" data-role="admin">Пользователь</div>
```

* `data-user-id` и `data-role` - это data-атрибуты.
* Все, что начинается с `data-`, можно свободно использовать.
* В JavaScript доступ через `element.dataset`.

#### Пример использования:

```html

<button data-product-id="42" data-price="99.99">Купить</button>
```

```js
const button = document.querySelector('button');

console.log(button.dataset.productId); // "42"
console.log(button.dataset.price); // "99.99"
```

* `dataset` — объект с ключами на основе имен атрибутов без `data-`.
* `data-product-id` — dataset.productId (в camelCase).

#### Для чего используют `data-*`?

* Хранение метаданных: ID, роли, состояния.
* Передача настроек из HTML в JS.
* Маркировка элементов без классов и id.
* Взаимодействие с событиями.

```html

<ul>
    <li data-id="1">Apple</li>
    <li data-id="2">Orange</li>
</ul>
```

```js
document.querySelector('ul').addEventListener('click', (e) => {
    if (e.target.dataset.id) {
        console.log('ID:', e.target.dataset.id);
    }
});
```

### 3. **CSS:** Объясни разницу между `relative`, `absolute`, `fixed` и `sticky` позиционированием в CSS.

В CSS есть несколько типов позиционирования элементов, которые управляются через свойство **position**. Вот основные из
них:

#### position: relative

* Элемент остается на своем месте в потоке документа.
* Можно сдвинуть его визуально с помощью **top**, **left**, **right**, **bottom**.
* При это его место сохраняется, другие элементы ведут себя так, будто он не двигался.

```css
.relative-box {
    position: relative;
    top: 10px;
    left: 20px;
}
```

Часто используется как контейнер для абсолютно позиционированных вложенных элементов.

#### position: absolute

* Элемент выпадает из потока документа — другие элементы игнорируют его.
* Он позиционируется относительно ближайшего родителя с position: relative, absolute, fixed или sticky.
* Если таких нет - от `<html>` (или `<body>`).

```css
.absolute-box {
    position: absolute;
    top: 0;
    right: 0;
}
```

Часто используют для всплывающих элементов, модальных окон, иконок внутри блоков.

#### position: fixed

* Элемент фиксируется относительно окна браузера, а не документа.
* Он всегда на экране, даже при прокрутке.

```css
.fixed-box {
    position: fixed;
    bottom: 20px;
    right: 20px;
}
```

Идеально для кнопок "вверх", всплывающих чатов, фиксированных меню.

#### position: sticky

* Комбинирует `relative` и `fixed`
* Пока элемент в пределах родителя — он ведет себя как `relative`.
* Когда достигает заданного порога (например, `top: 0`), он становится `fixed`.

```css
.sticky-box {
    position: sticky;
    top: 0;
}
```

Часто используют для прилипающих заголовков, табов, меню.

### 4. **CSS:** Что такое псевдоклассы и псевдоэлементы? Приведи примеры.

Псевдоклассы и псевдоэлементы — это специальные дополнения к селекторам в CSS, которые позволяют реагировать на
состояние элемента или оформлять его части, не добавляя новых классов или тегов в HTML.

#### Псевдоклассы (`:`)

Псевдоклассы описывают состояние или позицию элемента.

##### Примеры:

###### :hover

Когда курсор наводится на элемент

```css
a:hover {
    color: red
}
```

###### :focus

Когда элемент в фокусе (например, input)

```css
input:focus {
    outline: none;
}
```

###### :first-child

Первый потомок родителя

```css
p:first-child {
    font-weight: bold;
}
```

###### :nth-child(2)

Второй потомок родителя

```css
li:nth-child(2) {
    color: green;
}
```

###### :checked

Отмеченный чекбокс или радио

```css
input:checked + label {
    color: blue;
}
```

#### Псевдоэлементы (`::`)

Псевдоэлементы позволяют добавить стилизованные части внутри элементов — как будто бы добавили "виртуальные" элементы.

##### Примеры:

###### ::before

Вставляет контент перед содержимым элемента

```css
p::before {
    content: "+";
}
```

###### ::after

Вставляет контент после

```css
p::after {
    content: "-";
}
```

###### ::first-line

Стилизует первую строку текста

```css
p::first-line {
    font-weight: bold;
}
```

###### ::placeholder

Стилизует placeholder в input, textarea

```css
input::placeholder {
    color: gray;
}
```

#### Разница:

* Псевдокласс (`:`) работает с состоянием/позицией.
* Псевдоэлемент (`::`) работает с частью содержимого.

### 5. **CSS:** Как работает flexbox? Опиши свойства `justify-content` и `align-items`.

#### Что такое Flexbox?

**Flexbox** (Flexible Box) — это способ выстраивать элементы по одной оси (горизонтальной или вертикальной), легко
управляя отступами, выравниванием и порядком.

Чтобы включить флекс-контейнер:

```css
.container {
    display: flex;
}
```

#### Оси в Flexbox:

* main axis — главная ось (по умолчанию горизонтальная: слева направо)
* cross axis — поперечная ось (по умолчанию вертикальная: сверху вниз)

#### Свойства выравнивания

###### `justify-content` — выравнивание вдоль главной оси

Оно управляет расположением элементов по горизонтали (если `flex-direction: row`)

| Значение        | Что делает                                  |
|-----------------|---------------------------------------------|
| `flex-start`    | Прижимает всё к началу                      |
| `flex-end`      | Прижимает всё к концу                       |
| `center`        | Центрирует                                  |
| `space-between` | Равномерно с **пустым пространством между** |
| `space-around`  | Пространство **по бокам и между**           |
| `space-evenly`  | Равное пространство **везде**               |

```css
.container {
    display: flex;
    justify-content: center;
}
```

###### `align-items`  — выравнивание вдоль поперечной оси

Оно управляет вертикальным положением элементов (если `flex-direction: row`).

| Значение     | Что делает                                                 |
|--------------|------------------------------------------------------------|
| `stretch`    | Растягивает элементы по высоте контейнера *(по умолчанию)* |
| `flex-start` | Прижимает к верху                                          |
| `flex-end`   | Прижимает к низу                                           |
| `center`     | Центрирует по вертикали                                    |
| `baseline`   | Выравнивает по базовой линии текста                        |

```css
.container {
    display: flex;
    align-items: flex-end;
}
```

### 6. **JavaScript:** Что такое замыкания (`closures`) в JavaScript? Приведи пример.

### 7. **JavaScript:** Объясни разницу между `var`, `let` и `const`.

Оператор `var`

Оператор `let`

Оператор `const`

Сравнение `var`, `let` и `const`

### 8. **JavaScript:** Что такое асинхронное программирование? Как работают `Promises` и `async/await`?

Асинхронное программирование позволяет выполнять операции, не блокируя основной поток (`main thread`), например:

* Загрузка данных с сервера
* Ожидание ответа от API
* Таймеры, чтение файлов и др.

JavaScript однопоточный, но благодаря Event Loop и асинхронным механизмам может обрабатывать задачи "параллельно".

Проблема синхронного кода:

```js
const data = fetchData(); // долго
console.log(data); // это выполнится до получения данных (ошибка)
```

#### Promises - промисы

**Promise** — это объект, представляющий результат асинхронной операции.

```js
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('Успешно');
    }, 1000);
});

promise.then(result => {
    console.log(result); // "Успешно" через 1 секунду
}).catch(error => {
    console.error(error);
});
```

Состояния **Promise**:

* **pending** - в ожидании
* **fulfilled** - успешно завершен (**resolve**)
* **rejected** - завершен с ошибкой (**reject**)

#### Async/await - синтаксический сахар над Promise

Позволяет писать асинхронный код так, как будто он синхронный.

```js
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const json = await response.json();
    } catch (error) {
        console.error('Ошибка: ', error);
    }
}
```

* `await` приостанавливает выполнение функции до получения результата.
* Работает только внутри `async` функции.
* Удобнее читать и отсаживать, чем `.then()` и `.catch()`.

#### Сравнение:

* `Promise`
    * Загрузить данные с сервера:
        * fetch().then(...).catch(...)
    * Обработка ошибок:
        * .catch(...)
    * Много шагов подряд
        * Цепочки .then()
* `async/await`
    * Загрузить данные с сервера:
        * await fetch(...)
    * Обработка ошибок:
        * try { ... } catch { ... }
    * Много шагов подряд
        * await по порядку

#### Пример

```js
// Вариант с promise
function fetchUser(id) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({id, name: 'Alice'});
        }, 1000);
    });
}

// Вариант с async/await
async function showUser() {
    const user = await fetchUser(1);
    console.log(user.name); // Alice
}
```

### 9. **HTML/CSS/JS:** Как бы ты оптимизировал загрузку веб-страницы? Назови минимум 3 способа.

Оптимизация загрузки веб-страницы — ключ к быстрому, отзывчивому интерфейсу и лучшему SEO.

Некоторые эффективные способы оптимизации

#### 1. Минификация и сжатие файлов

* Уменьшение размеров CSS, JS и HTML — убрать пробелы, комментарии, лишние символы.
* Использование `minify`, `Webpack` или `esbuild`.
* Включение `Gzip` или `Brotli` на сервере.

#### 2. Загрузка JS и CSS отложено или асинхронно

* Для скриптов:

```html

<script src="app.js" defer></script>
```

или

```html

<script src="app.js" async></script>
```

* Для CSS - раздели на критические стили и второстепенные:

```html

<link rel="preload" href="style.css" as="style" onload="this.rel='stylesheet'">
```

#### 3. Оптимизация изображений

* Использовать форматы: WebP, AVIF вместо PNG/JPG.
* Уменьшение размера или разрешения перед загрузкой.

```html
<img src="image.webp" loading="lazy" alt="..."/>
```

### 10. **JavaScript:** Что такое делегация событий? Приведите пример кода.

Делегация событий (event delegation) — это важный прием в JavaScript, особенно когда работаешь с динамическими
элементами.

#### Что такое делегация событий?

Делегация событий — это техника, при которой вместо навешивания обработчиков на каждый элемент, вешается один обработчик
на родителя и обрабатываешь события от его потомков, используя `event.target`.

#### Зачем это нужно?

* Повышает производительность (меньше обработчиков)
* Упрощает работу с динамическими элементами, которые добавляют позже
* Делает код чище и управляемее

#### Пример без делегации (неэффективно)

```js
const buttons = document.querySelectorAll('.btn');

buttons.forEach(button => {
    button.addEventListener('click', () => {
        console.log('Button clicked');
    });
});
```

#### Пример с делегацией (лучше)

```html

<ul id="list">
    <li>Элемент 1</li>
    <li>Элемент 2</li>
    <li>Элемент 3</li>
</ul>
```

```js
const list = document.getElementById('list');

list.addEventListener('click', function (event) {
    if (event.target.tagName === 'li') {
        console.log('Вы нажали:', event.target.textContent);
    }
});
```

##### Что здесь происходит

* Добавлен слушатель на весь список
* Проверяем, что клик был по элементу `<li>`
* Обрабатываем событие

#### Как это работает в браузере

Событие в браузере проходит через фазы распространения:

1. Capturing (вверх → вниз)
2. Target (где кликнули)
3. Bubbling (всплытие: снизу → вверх)

Делегация работает на фазе всплытия (по умолчанию), и позволяет "перехватить" событие от потомков.__