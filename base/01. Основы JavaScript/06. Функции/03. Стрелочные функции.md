# Стрелочные функции (Arrow Functions)

Стрелочные функции (arrow functions) - это краткий синтаксис для создания функций в JavaScript, введенный в стандарте
ECMAScript 6 (ES6). Они упрощают написание анонимных фунций и часто используются в современных проектах, особенно с
массивами, промисами и колбэками.

## Основной синтаксис

Стрелочные функции используют символ `=>` (стрелку) для определения.

```js
// default function
function add(a, b) {
    return a + b;
}

// arrow function
const add = (a, b) => a + b;
```

* Если тело функции состоит из одного выражения, то фигурные скобки `{}` и ключевое слово `return` можно отпустить  
  (неявный возврат).
* Если параметров нет, используйте пустые скобки: `() => 'Hello'`.
* Если один параметр, скобки опустить: `x => x * 2`.
* Если несколько строк в теле, используйте `{}` и `return` явно:

```js
const greet = name => {
    if (name) {
        return `Hello, ${name}!`;
    } else {
        return `Hello, stranger!`;
    }
}
```

## Ключевые особенности и различия с обычными функциями

Стрелочные функции не просто сокращение — у них есть важные отличия:

### Отсутствие собственного `this`:

* В обычных функциях `this` зависит от контекста вызова (может быть `window`, объект и т.д.).
* В стрелочных функциях `this` наследуется из внешнего (лексического) контекста. Это делает их идеальными для методов
  объектов и колбэков.

**Пример с объектом:**

```js
const person = {
    name: 'John',
    sayHello: function () {
        setTimeout(function () {
            console.log(`Hello, ${this.name}!`); // undefined (this = window
        }, 1000);
    }
}

const personArrow = {
    name: 'Alice',
    sayHell: function () {
        setTimeout(() => {
            console.log(`Hello, ${this.name}!`); // person (this = person) 
        }, 1000);
    }
}
```

### Нет собственного `arguments`:

* Стрелочные функции не имеют массива `arguments`. Вместо этого используйте rest-параметры (`...args`).

```js
const sum = (...args) => args.reduce((acc, val) => acc + val, 0);
```

### Нельзя использовать как конструкторы:

* Нельзя вызвать с new: `new () => {}` выдаст ошибку. Они не имеют `prototype`.

### Не поддерживают `yield`:

* Нельзя использовать в генераторах (функция с function*).

### Краткость в колбэках:

* Идеальны для методов массивов вроде `map`, `filter`, `forEach`:

```js
const numbers = [1, 2, 3];
const doubled = numbers.map(x => x * 2); // [2,4,6
```

#### Когда использовать

* Для коротких функций, колбэков (например, в `Promise.then()`, `addEventListener`).
* В функциональном программировании для избежания проблем с `this`.
* Избегайте в методах объектов, если нужен динамический `this` (используйте обычные функции).

### Потенциальные подводные камни

* Если функция возвращает объект, оберните в скобки: `() => ({ key: 'value" })`, иначе {} воспримется как тело функции.
* В старых браузерах (до ES6) стрелочные функции не поддерживаются без полифиллов или Babel.

