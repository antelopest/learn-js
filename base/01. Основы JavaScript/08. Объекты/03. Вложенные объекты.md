# Вложенные объекты

В JavaScript вложенные объекты — это объекты, которые содержат другие объекты в качестве значений своих свойств.
Это позволяет создавать сложные структуры данных, такие как иерархии или модели с множеством уровней. Рассмотрим
ключевые аспекты работы с вложенными объектами, включая создание, доступ, изменение и распространенные сценарии
использования.

## Создание вложенных объектов

Вложенные объекты создаются так же, как обычные объекты, с использованием объектных литералов, конструкторов, классов
или других методов. Внутренние объекты просто задаются как значения свойств внешнего объекта.

### Пример с объектным литералом

```js
const person = {
    name: 'John',
    age: 30,
    address: {
        city: 'New York',
        street: '123 Main St.'
    },
    contacts: {
        email: "john@example.com",
        phone: {
            home: "555-123-4567",
            mobile: "555-987-6543"
        }
    }
};
```

## Доступ к свойствам вложенных объектов

Для доступа к свойствам вложенных объектов используются точечная нотация (`.`) или квадратная нотация (`[]`), как и для
обычных объектов.
Если требуется доступ к глубоко вложенным свойствам, вы комбинируете эти нотации.

### Пример

```js
console.log(person.address.city); // 'New York',
console.log(person["contacts"]["phone"]["mobile"]); // "555-987-6543"
```

### Динамический доступ

Если имя свойства хранится в переменной, используйте квадратную нотацию:

```js
const key = "city";
console.log(person.address[key]); // 'New York'
```

## Проверка существования вложенных свойств

При работе с вложенными объектами важно проверять, существуют ли промежуточные объекты, чтобы избежать ошибок вида
`Cannot read property 'city' of undefined`.

### Пример

```js
console.log(person.job.title); // TypeError: Cannot read property 'city' of undefined
```

#### Решение 1. Проверка с помощью if

```js
if (person.job && person.job.title) {
    console.log(person.job.title);
} else {
    console.log("Свойство job.title не существует");
}
```

#### Решение 2. Опциональная цепочка (`?.`)(ES2020)

Опциональная цепочка позволяет безопасно обращаться к вложенным свойствам.
Если промежуточное свойство не существует, возвращается `undefined`.

```js
console.log(person.job?.title); // undefined
console.log(person.contacts?.phone?.mobile); // "555-987-6543"
```

#### Решение 3. Логический оператор &&

```js
console.log(person.job && person.job.title); // undefined
```

## Изменение и добавление вложенных свойств

Вы можете изменять существующие свойства или добавлять новые во вложенные объекты.

### Пример

```js
person.address.city = "London";
console.log(person.address.city); // 'London'

person.address.zipCode = "123455";
console.log(person.address.zipCode); // '123455'

person.job = {
    title: "Software Engineer",
    company: "Google"
};

console.log(person.job.title);
```

#### Внимание:

Если промежуточный объект не существует, попытка добавить свойство вызовет ошибку:

```js
person.car.model = "BMW"; // TypeError: Cannot set property 'model' of undefined
```

##### Решение:

Сначала создайте промежуточный объект:

```js
person.car = {};
person.car.model = "BMW";
```

Или можно использовать опциональное присваивание:

```js
person.car = person.car || {};
person.car.model = "BMW";
```

## Удаление вложенных свойств

Для удаления свойства используют оператор `delete`.

### Пример

```js
delete person.address.zipCode;
console.log(person.address.zipCode); // undefined

delete person.contacts.phone;
console.log(person.contacts.phone); // undefined
```

## Итерация по вложенным объектам

Для работы с вложенными объектами часто требуется рекурсивно обходить их свойства.

```js
function printObject(obj, prefix = "") {
    for (let key in obj) {
        if (typeof obj[key] === "object" && obj[key] !== null) {
            printObject(obj[key], prefix + key + ".");
        } else {
            console.log(prefix + key + ": " + obj[key]);
        }
    }
}

printObject(person);

// Вывод:
// name: Алексей
// age: 30
// address.city: Санкт-Петербург
// address.street: Ленинский проспект
// address.house: 10
// contacts.email: alexey@example.com
// contacts.phone.mobile: +7-999-123-45-67
// contacts.phone.home: +7-495-765-43-21
```

## Копирование вложенных объектов

Простое копирование объекта (поверхностное) с помощью `Object.assign` или spread-оператора (`...`) копирует только
верхний уровень. Вложенные объекты остаются ссылками на оригинал.

### Пример поверхностного копирования:

```js
const personCopy = {...person};

personCopy.address.city = "Los Angeles";
console.log(person.address.city); // Los Angeles
```

#### Решение: Глубокое копирование

Для копирования всех уровней объекта можно использовать
`JSON.parse(JSON.stringify(obj))` или библиотеки, такие как `Lodash (_.cloneDeep)`.

```js
const deepCopy = JSON.parse(JSON.stringify(person));

deepCopy.address.city = "Los Angeles";
console.log(person.address.city); // "New York"
console.log(deepCopy.address.city); // "Los Angeles"
```

## Практические примеры

### Пример 1: Работа с API-данными

Часто данные из API возвращаются в виде вложенных объектов:

```js
const response = {
    user: {
        id: 1,
        profile: {
            name: "John",
            settings: {
                theme: "dark",
                notifications: true,
            }
        }
    }
};

console.log(response.user.profile.settings.theme); // dark
response.user.profile.settings.theme = "light";
console.log(response.user.profile.settings.theme); // light
```

### Пример 2: Безопасный доступ с опциональной цепочкой

```js
const data = {
    user: {
        profile: {
            name: "John"
        }
    }
};

console.log(data.user?.profile?.name); // John
console.log(data.user?.settings?.theme); // undefined
```

## Итог

* Вложенные объекты позволяют создавать сложные структуры данных.
* Доступ осуществляется через точечную (obj.prop) или квадратную (obj["prop"]) нотацию, с учетом проверки существования
  свойств.
* Опциональная цепочка (`?.`) упрощает безопасный доступ к глубоко вложенным свойствам.
* Для изменения или добавления свойств следите за существованием промежуточных объектов.
* Глубокое копирование необходимо для независимого изменения вложенных объектов.
* Рекурсия полезна для обработки сложных структур.

