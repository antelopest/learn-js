# Event Loop, microtasks and macrotasks

## Event Loop

Event Loop — это механизм в JavaScript, который управляет выполнением асинхронного кода в однопоточной среде. JavaScript
выполняется в одном потоке, но благодаря Event Loop он может обрабаывать асинхронные операции, какие как таймеры,
события DOM, промисы и сетевые запросы, без блокировки основного потока.

### Основные компоненты Event Loop

* Call Stack (Стек вызовов):
    * Место, где хранятся функции, которые выполняются в данный момент.
    * Работает по принципу LIFO (Last In, First Out).
    * Когда функция завершает выполнение, она снимается со стека.
* Task Queue (Очередь задач):
    * Хранит макротаски - задачи, которые должны быть выполнены асинхронно, например:
        * `setTimeout`, `setInterval`
        * Обработчик событий (`click`, `input`)
        * Сетевые запросы (`fetch`)
    * Макротаски выполняются по принципу FIFO (First In, First Out).
* Mickotask Queue (Очередь микрозадач):
* Web APIs:
    * В браузере Web APIs (например, `setTimeout`, `fetch`, `DOM-события`) обрабатываются вне основного потока
      JavaScript и
      возвращают результаты в Task Queue или Microtask Queue.
* Render Queue:
    * Отвечает за рендеринг UI (например, обновление DOM, перерисовка страницы).
    * Выполняется после микротасок, но перед макротасками, если требуется обновление UI (обычно с частотой ~60 FPS).

### Как работает Event Loop:

1. JavaScript выполняет синхронный код в Call Stack.
2. Когда встречается асинхронная операция (например, setTimeout или fetch), она передается в Web APIs.
3. После завершения асинхронной операции Web API отправляет задачу в соответствующую очередь:
    * Промисы и queueMicrotask -> Microtask Queue
    * setTimeout, события, fetch -> Task Queue
4. Event Loop проверяет:
    * Если Call Stack пуст, сначала выполняются все микротаски из Microtask Queue.
    * Затем, если нужно, выполняется рендеринг (Render Queue).
    * После этого выполняет одна макротаска из Task Queue.

* Этот процесс повторяется, пока очереди не опустеют.

## Микротаски и макротаски разница

* **Микротаски**:
    * Примеры: `promise.then`, `queueMicrotask`, `MutationObserver`.
    * Очередь: Microtask Queue.
    * Приоритет: Высокий (выполняет сразу после синхронного кода и перед рендерингом).
    * Поведение: Все микротаски выполняются в текущем цикле Event Loop до опустошения очереди.
    * Использование: Для задач, которые должны выполниться как можно скорее (напимер, обработка промисов)
* **Макротаски**:
    * Примеры: `setTimeout`, `setInterval`, события (`click`), `fetch`.
    * Очередь: Task Queue.
    * Приоритет: Низкий (выполняется после микротасок и рендеринга).
    * Поведение: Только одна макротаска выполняется за цикл Event Loop.
    * Использование: Для задач, которые могут подождать (например, таймеры, события).

### Примеры для понимания

#### Пример 1 — Микротаски и макротаски

```js
console.log('Start');

setTimeout(() => console.log('setTimeout'), 0); // Макротаска
Promise.resolve().then(() => console.log('Promise')); // Микротаска
queueMicrotask(() => console.log('queueMicrotask')); // Микротаска

console.log('End');
```

Вывод:

```
Start
End
Promise
queueMicrotask
setTimeout
```

Почему:

1. Синхронный код (`сonsole.log('Start)`, `console.log('End)`) выполняется сразу.
2. Promise.then и queueMickoTask добавляются в Microtask Queue и выполняют сразу после синхронного кода.
3. setTimeout добавляется в Task Queue и выполняется только после опустошения Microtask Queue.

#### Пример 2 — Микротаски блокируют рендеринг

```js
console.log('Start');

Promise
    .resolve()
    .then(() => {
        console.log('Promise 1');

        Promise.resolve().then(() => console.log('Promise 2')); // Microtask
    }); // Microtask

setTimeout(
    () => {
        console.log('setTimeout');
    }, 0
); // Macrotask

console.log('End');
```

Вывод:

```
Start
End
Promise 1
Promise 2
setTimeout
```

Почему:

* Микротаски (`Promise.then`) выполняются до завершения текущего цикла Event Loop, даже если добавляются новые
  микротаски.
* Это может блокировать рендеринг, если в Microtask Queue слишком много задач.

#### Пример 3 — Связь с вашим проектом (`SvgLoaderComponent`)

```js
class SvgLoaderComponent extends HTMLElement {
    async connectedCallback() {
        console.log('Start loading SVG');

        try {
            const response = await fetch('/icon.svg'); // Macrotask
            const svgText = await response.text(); // Microtask
            console.log('SVG loaded');

            queueMicrotask(() => console.log('Microtask after SVG')); // Microtask
            setTimeout(() => console.log('Timeout after SVG'), 0); // Macrotask
        } catch (e) {
            console.error('Error loading SVG');
        }

        console.log('End connectedCallback');
    }
}
```

Вывод:

```
Start loading SVG
End connectedCallback
SVG Loaded
Mickotask after SVG
Timeout after SVG
```

Почему:

* connectedCallback вызывается синхронно, когда компонент добавляется в DOM
* fetch создает макротаску, которая ждем ответ от сервера
* await response.text() создает микротаску для обработки ответа
* queueMicrotask добавляет еще одну микротаску, которая выполняется сразу после response.text()
* setTimeout добавляет макротаску, которая выполняется последней

## Сценарии использования и лучшие практики

1. Microtasks
    * Используйте для задач, которые должны выполниться немедленно после синхронного кода, но до рендеринга:
        * Обработка промисов (`Promise.then`)
        * Обновление состояния UI после асинхронных операций
        * Слишком много микротасок могут заморозить рендеринг, как как они выполняются до рендера.
2. Macrotasks
    * Используйте для задач, которые могут подождать:
        * Таймеры: `setTimeout`, `setInterval`
        * Обработка событий `click`, `input`
        * Сетевые запросы: `fetch`
3. Оптимизация производительности
    * Следует избегать большое количество микротасок, чтобы не блокировать UI рендеринг.

## Rendering UI

Rendering UI происходит после выполнения синхронного кода и выполнения всех микротасок в текущем Event Loop цикле.

### Как работает рендеринг в браузере:

Rendering UI (обновление DOM, layout, styles, composite) выполняется браузером в Render Queue, которая обрабатывается в
рамках цикла Event Loop.

Браузер не перерисовывает экран после каждой операции. Вместо этого он ждет, пока Call Stack не опустеет, все микротаски
не выполнятся,
и только тогда проверяет, нужно ли обновить UI.

Rendering UI происходит только если:

* DOM или styles изменились
* Прошел достаточный интервал времени для следующего кадра (обычно 16,7 мс при 60 FPS)

### Синхронный код и Call Stack:

* Синхронный код (например, console.log, change DOM через innerHTML, установка атрибутов) выполняется немедленно в Call
  Stack. 
* Любые 