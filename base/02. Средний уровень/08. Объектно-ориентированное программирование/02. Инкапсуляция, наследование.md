# Инкапсуляция, наследование

Инкапсуляция и наследование это ключевые концепции ООП.

## Инкапсуляция

Инкапсуляция — это принцип ООП, который заключается в скрытие внутренней реализации объекта и предоставлении доступа к
данным только через контролируемый интерфейс (методы). Это помогает защитить данные от некорректного использования и
упрощает управление состоянием объекта.

### Как реализовать инкапсуляция в JavaScript?

JavaScript предлагает несколько способов достижения инкапсуляции:

* Приватные свойства и методы с использованием символа # (c ES2020).
* Соглашения об именовании (например, префикс _ для "приватных свойств").
* Замыкания для скрытия данных (в функциональном стиле).
* Геттеры и сеттеры для контроля доступа к данным.

#### Пример с приватными переменными свойствами (#)

```js
class Person {
    #name;
    #age;

    constructor(name, age) {
        this.#name = name;
        this.#age = age;
    }

    getName() {
        return this.#name;
    }

    setName(name) {
        this.#name = name;
    }

    getAge() {
        return this.#age;
    }

    setAge(age) {
        if (age >= 0) {
            this.#age = age;
        } else {
            console.error("Age must be positive!")
        }
    }
}

const person = new Person("John", 30);

console.log(person.getName()); // John
console.log(person.getAge()); // 30

person.setName("Jane");
person.setAge(31);

console.log(person.#name); // Error: SyntaxError
```

#### Пример с соглашением об именовании (_)

До введения # в JavaScript использовали префикс _ для обозначения "приватных" свойств, хотя они технически не приватные:

```js
class Person {
    constructor(name, age) {
        this._name = name;
        this._age = age;
    }

    getName() {
        return this._name;
    }
}

const person = new Person("John", 25);
console.log(person.getName()); // John
console.log(person._name); // John
```

#### Пример с замыканиями

Замыкания позволяет создавать полностью приватные данные, недоступные извне:

```js
function createPerson(name, age) {
    let privateName = name;
    let privateAge = age;

    return {
        getName() {
            return privateName;
        },
        setName(name) {
            privateName = name;
        },
        getAge: () => privateAge,
        setAge: (age) => privateAge = age
    }
}

const person = createPerson("John", 25);

console.log(person.getName()); // John
console.log(person.getAge()); // 25
```

### Особенности инкапсуляции в JavaScript

* Приватные поля (#)
    * Настоящая приватность, введена в ES2020
    * Поля с # недоступные извне класса, даже через наследование
    * Пример: #field можно использовать только внутри класса, где оно объявлено
* Геттеры и сеттеры
    * Позволяют контролировать доступ и изменение данных
    * Объявляются с ключевыми словами get и set

```js
class Person {
    #name;

    constructor(name) {
        this.#name = name;
    }

    get name() {
        return this.#name;
    }

    set name(name) {
        this.#name = name.toUpperCase();
    }
}

const person = new Person("John");
console.log(person.name); // JOHN
person.name = "Jane";
console.log(person.name); // JANE
```

* Соглашения
    * Прификс _ — это просто договоренность, не обеспечивающая настоящей приватности.
* Практическое применение
    * Защита данных от случайного изменения
    * Создания публичного интерфейса для взаимодействия с объектом
    * Сокрытия сложной внутреннй логики

## Наследование

Наследование — это механизм ООП, позволяющий одному классу (дочернему) унаследовать свойства и методы другого класса
(родительского). В JavaScript наследование реализуется через прототипы, а синтаксис class и extends упрощает его
использование.

### Как реализуется наследование в JavaScript?

* Ключевое слово extends задает родительский класс.
* Ключевое слово super вызывает конструктор или методы родителя.
* Дочерний класс может переопределить методы родителя или добавлять новые.

```js
class Animal {
    constructor(name) {
        this.name = name;
    }

    makeSound() {
        console.log(`${this.name} makes a sound!`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }

    makeSound() {
        super.makeSound();
        console.log(`${this.name} makes a bark!`);
    }
}

const dog = new Dog("Rex", "Labrador");
dog.makeSound(); // Rex makes a bark!
```

### Особенности наследования

* Прототипная цепочка
    * JavaScript использует прототипное наследование. Дочерний класс наследует методы через [[Prototype]].
    * Например, Dog.prototype.__proto__ указывает на Animal.prototype.
* Переопределение методов
    * Дочерний класс может переопределить метод родителя, полностью заменяя его или дополняя с помощью super.
* Ограничения с приватными полями
    * Приватные поля (#field) недоступны в дочерних классах, что ограничивает прямой доступ к данным родителя.
* Множественное наследование:
    * JavaScript не поддерживает множественное наследование напрямую (один класс не может наследовать от нескольких).
      Для этого используются миксины или композиция.

Пример с переопределением и приватными полями

```js
class Person {
    #salary;

    constructor(name, salary) {
        this.name = name;
        this.#salary = salary;
    }

    getSalary() {
        return this.#salary;
    }
}

class Employee extends Person {
    constructor(name, salary, position) {
        super(name, salary);
        this.position = position;
    }

    describe() {
        console.log(`${this.name} work in ${this.position} salary ${this.getSalary()}`);
    }
}

const emp = new Employee("John", 50000, "developer");
emp.describe();
// console.log(emp.#salary); // Ошибка: приватное поле недоступно
```

### Практическое применение наследования:

* Создание иерархий классов (например, animal -> dog -> guideDog).
* Переиспользование кода родительского класса.
* Расширение функциональности (добавление новых методов или переопределение существующих).

## Сравнение инкапсуляция и наследования

* Инкапсуляция (скрытие данных и предоставление интерфейса) (приватные поля (#), get, set, замыкания).
* Наследование (переиспользование и расширение кода) (extends, super, прототипная цепочка).

## Полезные замечания

### Инкапсуляция

* Приватные поля (#) предпочтительнее для современной разработки, так как обеспечивает настоящую приватность
* Используйте геттеры и сеттеры для валидации данных
* Замыкания полезны, если нужно поддерживать старый код или работать без классов.

### Наследование

* Избегайте слишком глубокой иерархии наследования, так как это усложняет поддержку кода. Композиция (объединение
  объектов) часто предпочтительнее.
* Используйте super для вызова родительских методов, чтобы дублировать код.

### Комбинирование

* Инкапсуляция и наследование часто используются вместе. Например, родительский класс может инкапсулировать данные, а дочерний — расширяет функциональность.