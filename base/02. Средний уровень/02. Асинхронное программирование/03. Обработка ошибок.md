# Обработка ошибок (try...catch)

Обработка ошибок в асинхронном программировании в JavaScript с использованием конструкции `try...catch` — это важный
аспект, особенно при работе с `async/await`, который делает асинхронный код похожим на синхронный.

## Основы `try...catch`

Конструкция `try...catch` позволяет перехватывать и обрабатывать ошибки, возникающие в синхронном и асинхронном коде.
В контексте асинхронного программирования она чаще всего используется с `async/await`, так как это наиболее читаемый
способ работы с промисами.

### Синтаксис

```js
try {
    // Код, который может вызвать ошибку
} catch (error) {
    // Обработка ошибки
} finally {
    // Код, выполняемый всегда (опционально)
}
```

## `try...catch` в асинхронном коде

В асинхронных функциях `try...catch` используется для перехвата ошибок, возникающих при выполнении Promise (например,
при
отклонении Promise или сетевой ошибке).

### Пример с async/await

```js
async function fetchData() {
    try {
        const response = await fetch("https://api.example.com/data");
        if (!response.ok) throw new Error("Сетевой ответ не ok");

        const data = await response.json();
        console.log("Данные:", data);
    } catch (error) {
        console.error("Ошибка:", error.message);
    } finally {
        console.log("Запрос завершен");
    }
}

fetchData();
```

* **try:** Содержит асинхронный код, который может выбросить ошибку (например, fetch или response.json()).
* **catch:** Перехватывает любую ошибку, включая отклоненные промисы.
* **finally:** Выполняется независимо от успеха или ошибки, например, для очистки ресурсов.

## Обработка ошибок без `async/await`

Если вы работаете с промисами напрямую (без async/await), ошибки обрабатываются через `.catch()`:

```js
fetch("https://api.example.com/data")
    .then(response => {
        if (!response.ok) throw new Error("Сетевой ответ не ok");
        return response.json();
    })
    .then(data => console.log("Данные:", data))
    .catch(error => console.error("Ошибка:", error.message));
```

Однако `try...catch` не работает напрямую с `.then/.catch`, так как он предназначен для синхронного кода или кода внутри
async функции.

## Важные особенности

### Перехват всех ошибок

В асинхронной функции `try...catch` перехватывает как синхронные ошибки, так и отклонённые промисы.

```js
async function example() {
    try {
        // Синхронная ошибка
        let data = undefinedVariable; // ReferenceError
        // Асинхронная ошибка
        await Promise.reject(new Error("Промис отклонён"));
    } catch (error) {
        console.error("Поймана ошибка:", error.message);
    }
}

example();
```

### Пропуск ошибок

Если не использовать try...catch, непойманные ошибки в асинхронной функции могут привести к необработанному отклонению
промиса (unhandled rejection), что нежелательно.

### Глобальная обработка ошибок

Для перехвата необработанных ошибок промисов можно использовать событие `unhandledRejection`:

```js
window.addEventListener("unhandledRejection", event => {
    console.error("Необработанная ошибка промиса:", event.reason);
});
```

## Ограничения `try..catch` в асинхронном коде

### Не работает с callback

`try...catch` не перехватывает ошибки в функциях с callback, так как они выполняются вне текущего стека вызовов.

```js
setTimeout(() => {
    try {
        throw new Error("Ошибка в setTimeout");
    } catch (error) {
        console.error(error.message); // Перехватит ошибку
    }
}, 1000);

try {
    setTimeout(() => {
        throw new Error("Ошибка в setTimeout"); // Не перехватится
    }, 1000);
} catch (error) {
    console.error("Не сработает:", error);
}
```

**Решение:** Использовать Promise или помещать `try...catch` внутрь callback.

### Ограничение области видимости

`try...catch` работает только в пределах одной функции. Если ошибка возникает в другом контексте (например, в другом
Promise), её нужно обрабатывать через `.catch` или другой `try...catch`.

## Пример с несколькими промисами

Для обработки ошибок при выполнении нескольких Promise (например, с Promise.all) используйте `try...catch`:

```js
async function fetchMultiple() {
    try {
        const [data1, data2] = await Promise.all([
            fetch("https://api.example.com/data1").then(res => res.json()),
            fetch("https://api.example.com/data2").then(res => res.json())
        ]);
        console.log("Данные:", data1, data2);
    } catch (error) {
        console.error("Ошибка при загрузке:", error.message);
    }
}

fetchMultiple();
```

## Полезные советы

### Логирование ошибок

Всегда логируйте ошибки с достаточной информацией (например, error.message, error.stack) для отладки.

### Централизованная обработка

Для больших приложений создавайте обертки для асинхронных функций с единым механизмом обработки ошибок.

```js
async function witErrorHandling(fn) {
    try {
        return await fn();
    } catch (error) {
        console.error("Ошибка в операции:", error.message);
        throw error; // Пробрасываем ошибку дальше, если нужно
    }
}
```

### Используйте finally

Это удобно для выполнения очистки (например, сброс состояния загрузки).

### Избегайте смешанных подходов

Не комбинируйте `.then/.catch` и `try...catch` в одном коде без необходимости, чтобы сохранить читаемость.

## Итог

`try...catch` в асинхронном программировании с async/await — это мощный и удобный способ обработки ошибок, делающий код
более читаемым и похожим на синхронный. Он перехватывает как синхронные, так и асинхронные ошибки, но не работает с
колбэками без дополнительных оберток.
Для сложных сценариев комбинируйте `try...catch` с методами Promise (`Promise.all`, `.catch` и тд), а для глобальной
обработки используйте `unhandledRejection`.