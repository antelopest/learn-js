# Промисы (Promise)

Promises в JavaScript — это более современный и удобный способ работы с асинхронными операциями по сравнению с callback.
Они позволяют писать более читаемый и структурированный код, избегая "callbacks hell".

## Что такое Promise?

Promise — это объект, представляющий результат асинхронной операции, которая может завершиться успешно (fulfilled) или c
ошибкой (rejected).

Promise имеет три состояния:

1. **Pending (ожидание):** Операция еще не завершена.
2. **Fulfilled (выполнено):** Операция завершилась успешно, возвращен результат.
3. **Rejected (отклонено):** Операция завершилась с ошибкой.

## Создание Promise

Promise создается с помощью конструктора Promise, который принимает функцию с двумя параметрами:

* resolve (для успешного завершения)
* reject (для ошибки).

```js
const myPromise = new Promise(
    (resolve, reject) => {
        setTimeout(() => {
            const success = true;

            if (success) {
                resolve('Success');
            } else {
                reject(new Error('Error'));
            }
        }, 1000);
    }
)
```

## Основные методы

### .then(onFulfilled, onRejected):

Обрабатывается успешный результат (onFulfilled) или ошибку (onRejected).

### .catch(onRejected):

Обрабатывает только ошибки (аналог .then(null, onRejected)).

### .finally(onFinally):

Выполняется в любом случае, независимо от успеха или ошибки, что используется для очистки ресурсов.

## Пример использования

```js
myPromise
    .then(result => {
        console.log('Success: ', result);
        return result;
    })
    .then(nextResult => {
        console.log('Next result: ', nextResult);
    })
    .catch(error => {
        console.error('Operation error: ', error.message);
    })
    .finally(() => {
        console.log('Operation finished');
    });
```

## Цепочка промисов

Промисы позволяют создавать цепочки, где каждый `.then()` возвращает новый Promise, что делает код линейным и читаемым.

```js
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve("Data ready"), 1000);
    });
}

fetchData()
    .then(data => {
        console.log(data);
        return data.toUpperCase();
    })
    .then(upperData => {
        console.log(upperData);
    })
    .catch(error => {
        console.error("Ошибка:", error);
    });
```

## Обработка ошибок

Ошибки, возникшие в Promise или в любом `.then()`, автоматически передаются в ближайший `.catch()`.

```js
new Promise((resolve, reject) => {
    reject(new Error("Ошибка в промисе"));
})
    .then(() => {
        console.log("Этот код не выполнится");
    })
    .catch(error => {
        console.error(error.message); // "Ошибка в промисе"
    });
```

### .finally()

Используется для выполнения кода, который должен быть выполнен независимо от результата Promise (например, для скрытия
загрузочного индикатора).

```js
fetchData()
    .then(data => console.log(data))
    .catch(error => console.error(error))
    .finally(() => console.log("Operation finished, stop preloader"));
```

## Полезные методы Promise

### Promise.all(iterable):

Принимает массив Promises и возвращает новый Promise, который выполняется, когда все Promise в массиве завершены
успешно, или отклоняется при первой ошибке.

```js
Promise.all(
    [
        Promise.resolve(1),
        Promise.resolve(2),
        Promise.resolve(3)
    ]
).then(results => console.log(results)) // [1, 2, 3]
```

### Promise.race(iterable):

Возвращает результат самого быстрого Promise (успех или ошибка)

```js
Promise.race(
    [
        new Promise(resolve => setTimeout(() => resolve('First'), 500)),
        new Promise(resolve => setTimeout(() => resolve('Other'), 1000)),
        new Promise(resolve => setTimeout(() => resolve('Other'), 2000)),
    ]
).then(result => console.log(result)); // "First"
```

### Promise.resolve(value):

Создает сразу выполненный Promise.

### Promise.reject(error):

Создает сразу отклоненный Promise.

## Преимущества Promises

* **Читаемость:** Код выглядит линейно, без глубокой вложенности.
* **Обработка ошибок:** Централизованная через .catch()
* **Цепочки:** Легко комбинировать несколько асинхронных операций.
* **Совместимость:** Большинство современный API возвращают Promise.

## Ограничения

* Promise не отменяемы (нужны сторонние библиотеки или AbortController для этого).
* Для более сложной логики (например, последовательные операции с условиями) код может стать громоздким. Здесь помогает
  async/await.

## Пример с реальным API

```js
fetch("https://api.example.com/data")
    .then(response => {
        if (!response.ok) throw new Error("Сетевой ответ не ok");
        return response.json();
    })
    .then(data => console.log("Данные:", data))
    .catch(error => console.error("Ошибка:", error))
    .finally(() => console.log("Запрос завершён"));
```

## Итог

Promise — мощный инструмент для работы с асинхронными операциями, упрощающий управление результатами и ошибками.
Методы `.then()`, `.catch()` и `.finally()` позволяют строить гибкие цепочки обработки.
Для еще большей читаемости в современном JavaScript часто используют async/await, но понимание Promise остается
критически важным.