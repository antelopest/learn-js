# Замыкания (closures)

Замыкание (Closure) в JavaScript — это мощный и важный концепт, который позволяет функции "запоминать" окружение, в
котором она была создана, даже после того, как это окружение перестает существовать.

## Что такое замыкание?

Замыкание — это функция, которая имеет доступ к переменной из своей внешней (родительской) области видимости, даже после
того, как внешняя функция завершила свое выполнение. Это возможно благодаря тому, что функция сохраняет ссылку на
лексическое окружение (Lexical Environment), в котором она была определена.

## Ключевые моменты:

* Замыкание создается, когда внутренняя функция ссылается на переменные из внешней функции.
* Лексическое окружение — это объект, содержащий все переменные, доступные функции в момент ее создания.
* Замыкания позволяют сохранять состояние и создавать "приватные" данные.

## Как работает замыкание?

1. Лексическое окружение:
2. Сохранение окружения:
3. Возврат функции:

### Пример 1: Простое замыкание

```js
function createCounter() {
    let count = 0;

    function increment() {
        count++;
        console.log(count);
    }

    increment.resetCount = function () {
        count = 0;
    }

    return increment;
}

const counter = createCounter();

counter(); // 1
counter(); // 2
counter(); // 3

counter.resetCount();

counter(); // 0
```

#### Что происходит?

* Функция `createCounter` создает переменную `count` и внутреннюю функцию `increment`.
* `increment` использует count, создавая замыкание.
* Когда `createCounter` возвращает `increment`, переменная count сохраняется в памяти, и каждый вызов counter()
  увеличивает
  ее значение.
* Использовав функцию `resetCount`, можно сбросить значение переменной.

**Важно:** Каждый вызов `createCounter` создает новое лексическое окружение, поэтому можно создать несколько независимых
счетчиков.

```js
const counter1 = createCounter();
const counter2 = createCounter();

counter1(); // 1
counter2(); // 1
counter1(); // 2
counter2(); // 2
```

### Пример 2: Замыкание для создания приватных данных

Замыкания часто используются для эмуляции приватных переменных, которых нет в JavaScript на уровне языка.

```ts
function createPerson(name) {
    let age = 0;

    return {
        getName: function () {
            return name;
        },
        getAge: function () {
            return age;
        },
        growUp: function () {
            age++;
        }
    }
}

const person = createPerson('John');
console.log(person.getName()); // John
console.log(person.getAge()); // 0
person.growUp();
console.log(person.getAge()); // 1
console.log(person.age); // undefined (переменная приваткая)
```

#### Что происходит?

* Переменные `name` и `age` доступны только через методы объекта, возвращенного из `createPerson`.
* Внешний код не может напрямую получить доступ к `age` и `name`, что имитирует инкапсуляцию.

### Пример 3: Замыкание в циклах (классическая ловушка)

Часто замыкания вызывают путаницу при использовании в циклах. Рассмотрим классическую проблему:

```js
for (var i = 0; i < 3; i++) {
    setTimeout(function () {
        console.log(i);
    }, 1000);
}
// Вывод: 3, 3, 3
```

#### Почему так?

* Переменная i, объявленная через `var`, имеет функциональную область видимости и общая для всех итераций цикла.
* К моменту выполнения `setTimeout`, цикл уже завершен, и `i` равно `3`.

#### Решение 1: Использование let

```js
for (let i = 0; i < 3; i++) {
    setTimeout(function () {
        console.log(i);
    }, 1000);
}
// Вывод: 0, 1, 2
```

* let создаёт новую переменную i для каждой итерации, благодаря блочной области видимости.

#### Решение 2: Использование замыкания

```js
for (var i = 0; i < 3; i++) {
    (function (j) {
        setTimeout(function () {
            console.log(j);
        }, 1000);
    })(i);
}
// Вывод: 0, 1, 2
```

* Здесь мы создаем немедленно вызываемую функцию (IIFE), которая "захватывает" значение i в каждой итерации.

### Пример 4: Замыкание для создания фабрики функций

Замыкания полезны для создания функций с предустановленными параметрами.

```js
function createMultiplier(multiplier) {
    return function (number) {
        return number * multiplier;
    }
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

#### Что происходит?

* `createMultiplier` возвращает функцию, которая запоминает значение `multiplier`.
* Каждый вызов `createMultiplier` создает новое замыкание с уникальным значением `multiplier`.

## Когда использовать замыкания?

1. Инкапсуляция данных:
    * Для создания приватных переменных и методов, как в примере с `createPerson`.
2. Фабрики функций:
    * Для генерации функций с предустановленной логикой (как в примере с `createMultiplier`)
3. Сохранение состояния:
    * Для хранения данных между вызовами функции (как в примере со счетчиком).
4. Асинхронные операции:
    * Для сохранения контекста в `callback`, таймерах или обработчиках событий.
5. Модульный код:
    * Для создания модулей с закрытым состоянием.

## Типичные ошибки и ловушки

1. Переменные с var в циклах
    * Как показано в примере с `setTimeout`, использование var может привести к неожиданным результатам. Используйте
      `let`
      или замыкания для решения.
2. Утечки памяти
    * Замыкания удерживают ссылки на внешние переменные, что может привести к утечкам памяти, если замыкания не
      очищаются. Например, если замыкание привязано к событию, но не удаляется.
3. Сложность отладки
    * Замыкания могут усложнить понимание кода, если они используются избыточно или без ясной структуры.

## Заключение

Замыкания — это фундаментальная часть JavaScript, которая позволяет создавать гибкие и мощные конструкции. Они дают
возможность сохранять состояние, обеспечивать инкапсуляцию и управлять асинхронным кодом. Однако с замыканиями нужны
быть осторожным, чтобы избегать ошибок, связанных с областью видимости или утечками памяти.

## Практические задания

1. Создайте функцию `makeBankAccount`, которая возвращает объект с методами `deposit`, `withdraw`, `getBalance`.
   Переменная `balance` должна быть приватной и доступной только через эти методы.
2. Напишите функцию `memoize`, которая принимает функцию и возвращает ее мемоированную версию (результаты кэшируются для
   повторных вызовов с теми же аргументами).
3. Исправьте следующий код, чтобы он выводил числа от 1 до 5 с интервалом в 1 секунду.

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(function () {
        console.log(i);
    }, i * 1000);
}
// Текущий вывод: 6, 6, 6, 6, 6
```

### Ответы на практические задания

#### Задание 1

Создайте функцию `makeBankAccount`, которая возвращает объект с методами `deposit`, `withdraw`, `getBalance`.
Переменная `balance` должна быть приватной и доступной только через эти методы.

##### Решение

```js
function makeBankAccount(initialBalance) {
    let balance = initialBalance || 0;

    function deposit(amount) {
        balance += amount;
    }

    function withdraw(amount) {
        balance -= amount;
    }

    function getBalance() {
        return balance;
    }

    return {
        deposit,
        withdraw,
        getBalance
    }
}

const account = makeBankAccount(100);
console.log(account.getBalance()); // 100
account.deposit(20);
console.log(account.getBalance()); // 120
account.withdraw(30);
console.log(account.getBalance()); // 90
```

#### Задание 2

Напишите функцию `memoize`, которая принимает функцию и возвращает ее мемоированную версию (результаты кэшируются для
повторных вызовов с теми же аргументами).

##### Решение

```js
function memoize(fn) {
    const cache = {};

    return function (...args) {
        console.log(cache);
        const key = JSON.stringify(args);

        if (key in cache) {
            return cache[key];
        }

        const result = fn(...args);
        cache[key] = result;
    }
}

const slowFunction = (num) => {
    console.log('Computing...');
    return num * num;
}

const memoizedFunction = memoize(slowFunction);
console.log(memoizedFunction(5)); // Computing...25
console.log(memoizedFunction(5)); // 25
```

#### Задание 3

Исправьте следующий код, чтобы он выводил числа от 1 до 5 с интервалом в 1 секунду.

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(function () {
        console.log(i);
    }, i * 1000);
}
// Текущий вывод: 6, 6, 6, 6, 6
```

##### Решение с использованием let

`let` в отличие от `var` имеет блочную область видимости.
Поэтому на каждой итерации цикла i будет иметь разное значение.

```js
for (let i = 1; i <= 5; i++) {
    setTimeout(function () {
        console.log(i);
    }, i * 1000);
}
// Текущий вывод: 6, 6, 6, 6, 6
```

##### Решение с помощью замыкания

```js
for (var i = 1; i <= 5; i++) {
    (function (j) {
        setTimeout(function () {
            console.log(j);
        }, j * 1000);
    })(i);
}
// Вывод: 1, 2, 3, 4, 5
```
