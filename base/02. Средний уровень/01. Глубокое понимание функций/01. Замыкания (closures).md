# Замыкания (closures)

Замыкание (Closure) в JavaScript — это мощный и важный концепт, который позволяет функции "запоминать" окружение, в
котором она была создана, даже после того, как это окружение перестает существовать.

## Что такое замыкание?

Замыкание — это функция, которая имеет доступ к переменной из своей внешней (родительской) области видимости, даже после
того, как внешняя функция завершила свое выполнение. Это возможно благодаря тому, что функция сохраняет ссылку на
лексическое окружение (Lexical Environment), в котором она была определена.

Ключевые моменты:

* Замыкание создается, когда внутренняя функция ссылается на переменные из внешней функции.
* Лексическое окружение — это объект, содержащий все переменные, доступные функции в момент ее создания.
* Замыкания позволяют сохранять состояние и создавать "приватные" данные.

## Как работает замыкание?

1. Лексическое окружение:
2. Сохранение окружения:
3. Возврат функции:

### Пример: Простое замыкание

```js
function createCounter() {
    let count = 0;

    function increment() {
        count++;
        console.log(count);
    }

    increment.resetCount = function () {
        count = 0;
    }

    return increment;
}

const counter = createCounter();

counter(); // 1
counter(); // 2
counter(); // 3

counter.resetCount();

counter(); // 0
```

#### Что происходит?

* Функция `createCounter` создает переменную `count` и внутреннюю функцию `increment`.
* `increment` использует count, создавая замыкание.
* Когда `createCounter` возвращает `increment`, переменная count сохраняется в памяти, и каждый вызов counter()
  увеличивает
  ее значение.
* Использовав функцию `resetCount`, можно сбросить значение переменной.

**Важно:** Каждый вызов `createCounter` создает новое лексическое окружение, поэтому можно создать несколько независимых
счетчиков.

```js
const counter1 = createCounter();
const counter2 = createCounter();

counter1(); // 1
counter2(); // 1
counter1(); // 2
counter2(); // 2
```

### Пример: Замыкание для создания приватных данных

Замыкания часто используются для эмуляции приватных переменных, которых нет в JavaScript на уровне языка.

```ts
function createPerson(name) {
    let age = 0;

    return {
        getName: function () {
            return name;
        },
        getAge: function () {
            return age;
        },
        growUp: function () {
            age++;
        }
    }
}

const person = createPerson('John');
console.log(person.getName()); // John
console.log(person.getAge()); // 0
person.growUp();
console.log(person.getAge()); // 1
console.log(person.age); // undefined (переменная приваткая)
```

#### Что происходит?

* Переменные `name` и `age` доступны только через методы объекта, возвращенного из `createPerson`.
* Внешний код не может напрямую получить доступ к `age` и `name`, что имитирует инкапсуляцию.

### Пример: Замыкание для создания фабрики функций

Замыкания полезны для создания функций с предустановленными параметрами.

```js
function createMultiplier(multiplier) {
    return function (number) {
        return number * multiplier;
    }
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

#### Что происходит?

* `createMultiplier` возвращает функцию, которая запоминает значение `multiplier`.
* Каждый вызов `createMultiplier` создает новое замыкание с уникальным значением `multiplier`.

## Когда использовать замыкания?

1. Инкапсуляция данных:
    * Для создания приватных переменных и методов, как в примере с `createPerson`.
2. Фабрики функций:
    * Для генерации функций с предустановленной логикой (как в примере с `createMultiplier`)
3. Сохранение состояния:
    * Для хранения данных между вызовами функции (как в примере со счетчиком).
4. Асинхронные операции:
    * Для сохранения контекста в `callback`, таймерах или обработчиках событий.
5. Модульный код:
    * Для создания модулей с закрытым состоянием.

## Заключение

Замыкания — это фундаментальная часть JavaScript, которая позволяет создавать гибкие и мощные конструкции. Они дают
возможность сохранять состояние, обеспечивать инкапсуляцию и управлять асинхронным кодом. Однако с замыканиями нужны
быть осторожным, чтобы избегать ошибок, связанных с областью видимости или утечками памяти.