'use strict';

/*
* Материал взят из цикла статей learn js
* Рекурсия и стек
* Рекурсия - это прием программирования, когда здача может быть естественно разделена на несколько аналогичных, но более
* простых задач.
* Частный случай подвызова - когда функция вызывает сама себя. Это называется рекурсией.
*
* Простой пример функции, которая возвращает x в степени n
*/

const pow_1 = (x, n) => Math.pow(x, n);
console.log(pow_1(6,2));
// or
const pow_2 = (x, n) => {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
};
console.log(pow_2(6, 2));
// or
function pow_3(x, n) {
  if (n === 1) return x;
  else return x * pow_3(x, n - 1); // x^n = x * x^(n-1) // шаг рекурсии
}
console.log(pow_3(6, 3));
// Шаги рекурсии
// pow(6, 3) = 6 * pow(6, 2)
// pow(6, 2) = 6 * pow(6, 1)
// pow(6, 1) = 6
// pow(6, 3) = 6 * 6 * 6

// or
function pow_4(x, n) {
  return n === 1 ? x : x * pow_4(x, n -1 );
}
console.log(pow_4(6, 3));

/*
* Общее число вложенных вызовово (включая первый) называют глубиной рекурсии.
* В нашем случае глубина рекурсии будет n
* Максимальная глубина рекурсии ограничена движком JS
* Глубина расчитана от 10000 до 100000 в зависимости от интерпретатора
*
* Информация о процессе выполнения запущенной функции хранится в её контекте выполнения (execution context)
*
* Контекст выполнения - специальная внутренняя структура данных, которая содержит информацию о вызове функции.
* Один вызов функции имеет ровно один контекст выполнения связанный с ним.
*
* Когда функция производит вложенный вызов, происходит следующее:
* 1. Выполнение текущей функции приостанавливается.
* 2. Контекст выполнения, связанный с ней, запоминается в специальной структуре данных - стеке контекстов выполнения.
* 3. Выполняются вложенные вызовы, для каждого из которых создается свой контекст выполнения.
* 4. После их завершения старый контекст достается из стека, и выполнение внешней функции возобновляется с того места,
*    где на была оставлена.
*/

/*
* Рассмотрим подробно контекст выполнения функции pow_4 (6, 3)
* 1. Контекст x = 6, n = 3, вызов pow_4(6, 3)
* 2. Вызов pow_4(6, 2)
* 3. Для выполнения вложенного вызова JS запоминает текущий контекст выполнения в стеке контекстов выполнения
*    Текущий контекст запоминается в вершине стека
*    Создается новый контекст для вложенного вызова
*    Когда выполнение вложенного вызова заканчивается - контекст предыдущего вызоза восстанавливается и выполнение
*    соответствующей функции продолжается.
* Контекст x = 6, n = 1 - текущий // возвращает 6
* Контекст x = 6, n = 2 - старый // возвращает 36
* Контекст x = 6, n = 3 - старый // возвращает 216
* Глубина рекурсии 3
* Грубина рекурсии = числа контекстов
*
* Любая рекурсия может быть переделана в цикл.
* И как правило цикл будет эффективнее.
*
* Итоги:
* Рекурсия - это термин в программировании, означающий вызов функцией самой себя.
* Когда функция вызывает саму себя - это называется шагом рекурсии.
*
* Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы.
* Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.
*/

/*
* Решение задачи FizzBuss рекурсивным методом
* (просто для альтернативы)
* Если число делится на 15 то выдать FizzBuss
* Если число делится на 5 то выдать Buss
* Если число делится на 3 то выдать Fizz
*/

function FizzBuss(i = 1) {
  if (i % 15 === 0) console.log('FizzBuss');
  else if (i % 5 === 0) console.log('Buss');
    else if (i % 3 === 0) console.log('Fizz');
      else console.log(i);
  if (i === 100) return;
  FizzBuss(++i);
}
FizzBuss();

// or
function FizzBuss_1(i = 1) {
  console.log((i % 15 === 0) ? ('FizzBuss') :
    (i % 5 === 0) ? ('Buss') :
      (i % 3 === 0) ? ('Fizz') : i);
  if (i === 100) return;
  FizzBuss(++i);
}
FizzBuss_1();
